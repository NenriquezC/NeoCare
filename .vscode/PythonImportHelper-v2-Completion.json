[
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordBearer",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordBearer",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "DateTime",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Numeric",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UniqueConstraint",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "UserRegister",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserLogin",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserOut",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserRegister",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserLogin",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_token",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_token",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "Settings",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "BoardBase",
        "importPath": "app.boards.schemas",
        "description": "app.boards.schemas",
        "isExtraImport": true,
        "detail": "app.boards.schemas",
        "documentation": {}
    },
    {
        "label": "BoardOut",
        "importPath": "app.boards.schemas",
        "description": "app.boards.schemas",
        "isExtraImport": true,
        "detail": "app.boards.schemas",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "importPath": "app.auth.routes",
        "description": "app.auth.routes",
        "isExtraImport": true,
        "detail": "app.auth.routes",
        "documentation": {}
    },
    {
        "label": "auth_router",
        "importPath": "app.auth.routes",
        "description": "app.auth.routes",
        "isExtraImport": true,
        "detail": "app.auth.routes",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Card",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "TimeEntry",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "BoardMember",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Card",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "sync_playwright",
        "importPath": "playwright.sync_api",
        "description": "playwright.sync_api",
        "isExtraImport": true,
        "detail": "playwright.sync_api",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "boards_router",
        "importPath": "app.boards.routes",
        "description": "app.boards.routes",
        "isExtraImport": true,
        "detail": "app.boards.routes",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "backend.app.auth.routes",
        "description": "backend.app.auth.routes",
        "peekOfCode": "def register(user: UserRegister, db: Session = Depends(get_db)):\n    \"\"\"\n    Crea un usuario nuevo y retorna un token de acceso JWT.\n    Parámetros:\n        user (UserRegister): Datos de registro recibidos en el cuerpo de la petición.\n        db (Session): Sesión de base de datos proporcionada por FastAPI.\n    Retorna:\n        Token: Diccionario con el JWT generado y el tipo de token.\n    Excepciones:\n        HTTP 400: Si el email ya está registrado en el sistema.",
        "detail": "backend.app.auth.routes",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "backend.app.auth.routes",
        "description": "backend.app.auth.routes",
        "peekOfCode": "def login(user: UserLogin, db: Session = Depends(get_db)):\n    \"\"\"\n    Autentica un usuario existente y retorna un token JWT si las credenciales son correctas.\n    Parámetros:\n        user (UserLogin): Credenciales enviadas por el cliente.\n        db (Session): Sesión de base de datos proporcionada por FastAPI.\n    Retorna:\n        Token: Diccionario con el JWT generado y el tipo de token.\n    Excepciones:\n        HTTP 401: Si el email no existe o la contraseña no coincide.",
        "detail": "backend.app.auth.routes",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "backend.app.auth.routes",
        "description": "backend.app.auth.routes",
        "peekOfCode": "router = APIRouter(prefix=\"/auth\", tags=[\"auth\"])\n@router.post(\"/register\", response_model=Token)\ndef register(user: UserRegister, db: Session = Depends(get_db)):\n    \"\"\"\n    Crea un usuario nuevo y retorna un token de acceso JWT.\n    Parámetros:\n        user (UserRegister): Datos de registro recibidos en el cuerpo de la petición.\n        db (Session): Sesión de base de datos proporcionada por FastAPI.\n    Retorna:\n        Token: Diccionario con el JWT generado y el tipo de token.",
        "detail": "backend.app.auth.routes",
        "documentation": {}
    },
    {
        "label": "UserRegister",
        "kind": 6,
        "importPath": "backend.app.auth.schemas",
        "description": "backend.app.auth.schemas",
        "peekOfCode": "class UserRegister(BaseModel):\n    \"\"\"\n    Esquema para recibir datos de registro de usuario.\n    Campos:\n        email (EmailStr): Correo electrónico válido.\n        password (str): Contraseña del usuario.\n        name (str, opcional): Nombre del usuario.\n    \"\"\"\n    email: EmailStr\n    password: str",
        "detail": "backend.app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserLogin",
        "kind": 6,
        "importPath": "backend.app.auth.schemas",
        "description": "backend.app.auth.schemas",
        "peekOfCode": "class UserLogin(BaseModel):\n    \"\"\"\n    Esquema para datos de login (inicio de sesión).\n    Campos:\n        email (EmailStr): Correo electrónico válido.\n        password (str): Contraseña del usuario.\n    \"\"\"\n    email: EmailStr\n    password: str\nclass Token(BaseModel):",
        "detail": "backend.app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "backend.app.auth.schemas",
        "description": "backend.app.auth.schemas",
        "peekOfCode": "class Token(BaseModel):\n    \"\"\"\n    Esquema de respuesta para el token JWT.\n    Campos:\n        access_token (str): Token de acceso generado.\n        token_type (str): Tipo de autenticación (bearer por defecto).\n    \"\"\"\n    access_token: str\n    token_type: str = \"bearer\"",
        "detail": "backend.app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:\n        str: Contraseña encriptada/hasheada.\n    \"\"\"\n    if password is None:\n        password = \"\"",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def verify_password(plain: str, hashed: str) -> bool:\n    \"\"\"\n    Verifica que la contraseña en texto plano coincida con el hash almacenado.\n    Args:\n        plain (str): Contraseña en texto plano proporcionada por el usuario.\n        hashed (str): Contraseña hasheada almacenada en la base de datos.\n    Returns:\n        bool: True si coincide, False si no.\n    \"\"\"\n    if plain is None:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_token",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def create_token(data: dict):\n    \"\"\"\n    Genera un token JWT codificando los datos de usuario.\n    Args:\n        data (dict): Datos a incluir en el payload del token.\n    Returns:\n        str: Token JWT generado.\n    \"\"\"\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MIN)",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def get_db():\n    \"\"\"\n    Genera una sesión nueva de base de datos para inyectar en rutas de FastAPI.\n    Yields:\n        Session: Sesión SQLAlchemy.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def get_current_user(token: str = Depends(oauth2_scheme),db: Session = Depends(get_db)):\n    \"\"\"\n    Obtiene el usuario actual autenticado a partir del token JWT.\n    Args:\n        token (str): Token JWT extraído automáticamente por FastAPI.\n        db (Session): Sesión SQLAlchemy, inyectada.\n    Raises:\n        HTTPException: Si el token es inválido o el usuario no existe.\n    Returns:\n        User: Instancia del usuario autenticado en base de datos.",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "SECRET_KEY = \"CAMBIA_ESTA_CLAVE\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MIN = 60\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MIN = 60\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MIN",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MIN = 60\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "oauth2_scheme",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:\n        str: Contraseña encriptada/hasheada.",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:\n        str: Contraseña encriptada/hasheada.\n    \"\"\"",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class User(Base):\n    \"\"\"\n    Modelo de usuario del sistema.\n    Representa una cuenta con credenciales y relaciones hacia tableros,\n    tarjetas y registros de tiempo.\n    Campos principales:\n        id (int): Identificador único del usuario.\n        email (str): Correo único.\n        password_hash (str): Contraseña encriptada.\n        name (str): Nombre del usuario.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class Board(Base):\n    \"\"\"\n    Modelo de tablero Kanban.\n    Representa un tablero donde los usuarios organizan listas y tarjetas.\n    Campos principales:\n        id (int): Identificador único de tablero.\n        name (str): Nombre del tablero.\n        user_id (int): Usuario propietario del tablero.\n        created_at (datetime): Fecha de creación.\n    Relaciones:",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class List(Base):\n    \"\"\"\n    Modelo de lista dentro de un tablero.\n    Permite agrupar tarjetas por proceso, etapa o categoría.\n    Campos principales:\n        id (int): Identificador único de la lista.\n        board_id (int): Tablero al que pertenece.\n        name (str): Nombre de la lista.\n        position (int): Posición en el tablero.\n        created_at (datetime): Fecha de creación.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "Card",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class Card(Base):\n    \"\"\"\n    Modelo de tarjeta/do Kanban.\n    Define tareas o ítems que pueden moverse entre listas y tableros.\n    Campos principales:\n        id (int): Identificador único de la tarjeta.\n        board_id, list_id (int): Relación con tablero y lista.\n        title (str): Título de la tarea.\n        description (Text): Descripción detallada.\n        due_date (Date): Fecha de entrega.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "TimeEntry",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class TimeEntry(Base):\n    \"\"\"\n    Registro de tiempo invertido en una tarjeta.\n    Permite cuantificar esfuerzos y generar historiales de trabajo.\n    Campos principales:\n        id (int): Identificador único.\n        user_id (int): Usuario que registró el tiempo.\n        card_id (int): Tarjeta asociada.\n        date (Date): Fecha del registro.\n        hours (Numeric): Horas trabajadas.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "BoardMember",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class BoardMember(Base):\n    \"\"\"\n    Asociación entre usuarios y tableros (membresías).\n    Permite controlar roles y accesos de los usuarios a los tableros.\n    Campos principales:\n        id (int): Identificador único.\n        board_id (int): Tablero asociado.\n        user_id (int): Usuario asociado.\n        role (str): Rol dentro del tablero.\n    Restricciones:",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "get_boards",
        "kind": 2,
        "importPath": "backend.app.boards.routes",
        "description": "backend.app.boards.routes",
        "peekOfCode": "def get_boards(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Obtiene todos los tableros pertenecientes al usuario autenticado.\n    Nota (importante):\n        Si el usuario NO tiene tableros (usuarios antiguos creados antes de la creación automática),\n        se crea automáticamente 1 tablero y sus 3 listas por defecto para evitar que el frontend\n        quede bloqueado.\n    \"\"\"\n    boards = (\n        db.query(Board)",
        "detail": "backend.app.boards.routes",
        "documentation": {}
    },
    {
        "label": "get_board_lists",
        "kind": 2,
        "importPath": "backend.app.boards.routes",
        "description": "backend.app.boards.routes",
        "peekOfCode": "def get_board_lists(\n    board_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Devuelve las listas (columnas) de un tablero específico.\n    Reglas de seguridad:\n        - El tablero debe existir.\n        - El tablero debe pertenecer al usuario autenticado.",
        "detail": "backend.app.boards.routes",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "backend.app.boards.routes",
        "description": "backend.app.boards.routes",
        "peekOfCode": "router = APIRouter(prefix=\"/boards\", tags=[\"boards\"])\n@router.get(\"/\", response_model=ListType[BoardOut])\ndef get_boards(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Obtiene todos los tableros pertenecientes al usuario autenticado.\n    Nota (importante):\n        Si el usuario NO tiene tableros (usuarios antiguos creados antes de la creación automática),\n        se crea automáticamente 1 tablero y sus 3 listas por defecto para evitar que el frontend\n        quede bloqueado.\n    \"\"\"",
        "detail": "backend.app.boards.routes",
        "documentation": {}
    },
    {
        "label": "ListOut",
        "kind": 6,
        "importPath": "backend.app.boards.schemas",
        "description": "backend.app.boards.schemas",
        "peekOfCode": "class ListOut(BaseModel):\n    \"\"\"Schema para serializar una lista (columna de un tablero).\"\"\"\n    id: int\n    name: str\n    board_id: int\n    position: int\n    created_at: datetime\n    model_config = ConfigDict(from_attributes=True)\nclass BoardOut(BaseModel):\n    \"\"\"Schema para serializar un tablero.\"\"\"",
        "detail": "backend.app.boards.schemas",
        "documentation": {}
    },
    {
        "label": "BoardOut",
        "kind": 6,
        "importPath": "backend.app.boards.schemas",
        "description": "backend.app.boards.schemas",
        "peekOfCode": "class BoardOut(BaseModel):\n    \"\"\"Schema para serializar un tablero.\"\"\"\n    id: int\n    name: str\n    user_id: int\n    created_at: datetime\n    model_config = ConfigDict(from_attributes=True)",
        "detail": "backend.app.boards.schemas",
        "documentation": {}
    },
    {
        "label": "verify_board_permission",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def verify_board_permission(board_id: int, user_id: int, db: Session):\n    \"\"\"\n    Verifica que el tablero existe y pertenece al usuario.\n    \"\"\"\n    board = db.query(Board).filter(Board.id == board_id).first()\n    if not board:\n        raise HTTPException(status_code=404, detail=\"Tablero no encontrado\")\n    if board.user_id != user_id:\n        raise HTTPException(status_code=403, detail=\"No tienes permiso para este tablero\")\n    return board",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "create_card",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def create_card(\n    data: CardCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Crea una nueva tarjeta (card) en un tablero y lista especificados.\n    \"\"\"\n    verify_board_permission(data.board_id, current_user.id, db)\n    new_card = Card(",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "get_cards",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def get_cards(\n    board_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    verify_board_permission(board_id, current_user.id, db)\n    return (\n        db.query(Card)\n        .filter(Card.board_id == board_id)\n        .order_by(Card.list_id, Card.position)",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "get_card",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def get_card(\n    card_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Obtiene una tarjeta por ID (si pertenece a un board del usuario).\n    \"\"\"\n    card = db.query(Card).filter(Card.id == card_id).first()\n    if not card:",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "update_card_patch",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def update_card_patch(\n    card_id: int,\n    data: CardUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Edita una tarjeta existente (PATCH).\n    - Solo aplica los campos que vienen en el body.\n    \"\"\"",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "update_card_put",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def update_card_put(\n    card_id: int,\n    data: CardUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Edita una tarjeta existente (PUT).\n    \"\"\"\n    card = db.query(Card).filter(Card.id == card_id).first()",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "move_card",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def move_card(\n    card_id: int,\n    data: CardMove,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Mueve una tarjeta entre columnas o dentro de la misma columna (Drag & Drop).\n    El backend es la autoridad del orden:\n    - valida permisos",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "delete_card",
        "kind": 2,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "def delete_card(\n    card_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    \"\"\"\n    Elimina una tarjeta por ID si pertenece a un tablero del usuario autenticado.\n    Retorna 204 si se elimina correctamente.\n    \"\"\"\n    card = db.query(Card).filter(Card.id == card_id).first()",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "backend.app.cards.routes",
        "description": "backend.app.cards.routes",
        "peekOfCode": "router = APIRouter(prefix=\"/cards\", tags=[\"cards\"])\n\"\"\"Módulo de endpoints para la gestión de 'cards' (tarjetas).\nContiene rutas para crear, listar, obtener, actualizar y eliminar tarjetas.\nCada endpoint valida que el tablero (board) pertenezca al usuario autenticado\nantes de realizar operaciones que afecten a los recursos.\n\"\"\"\ndef verify_board_permission(board_id: int, user_id: int, db: Session):\n    \"\"\"\n    Verifica que el tablero existe y pertenece al usuario.\n    \"\"\"",
        "detail": "backend.app.cards.routes",
        "documentation": {}
    },
    {
        "label": "CardCreate",
        "kind": 6,
        "importPath": "backend.app.cards.schemas",
        "description": "backend.app.cards.schemas",
        "peekOfCode": "class CardCreate(BaseModel):\n    \"\"\"\n    Esquema para crear una tarjeta (Card).\n    Campos:\n    - title (str): Título obligatorio de la tarjeta. Tiene longitud mínima de 1 carácter.\n    - description (Optional[str]): Descripción opcional de la tarjeta.\n    - due_date (Optional[date]): Fecha límite opcional para la tarjeta (solo fecha).\n    - board_id (int): Identificador del tablero al que pertenece la tarjeta.\n    - list_id (int): Identificador de la lista dentro del tablero donde se crea la tarjeta.\n    Validación destacada:",
        "detail": "backend.app.cards.schemas",
        "documentation": {}
    },
    {
        "label": "CardUpdate",
        "kind": 6,
        "importPath": "backend.app.cards.schemas",
        "description": "backend.app.cards.schemas",
        "peekOfCode": "class CardUpdate(BaseModel):\n    \"\"\"\n    Esquema para actualizar parcialmente una tarjeta existente.\n    Campos (todos opcionales):\n    - title (Optional[str]): Nuevo título; si se proporciona, debe ser una cadena.\n    - description (Optional[str]): Nueva descripción.\n    - due_date (Optional[date]): Nueva fecha límite (solo fecha).\n    - list_id (Optional[int]): Nuevo identificador de lista para mover la tarjeta.\n    - archived (Optional[bool]): Marcar/desmarcar la tarjeta como archivada.\n    Uso:",
        "detail": "backend.app.cards.schemas",
        "documentation": {}
    },
    {
        "label": "CardMove",
        "kind": 6,
        "importPath": "backend.app.cards.schemas",
        "description": "backend.app.cards.schemas",
        "peekOfCode": "class CardMove(BaseModel):\n    \"\"\"\n    Esquema para mover/reordenar una tarjeta (Semana 3 Drag & Drop).\n    Campos:\n    - list_id (int): columna destino.\n    - order (int): nueva posición dentro de la columna destino (>= 0).\n    \"\"\"\n    list_id:int\n    order: int = Field(..., ge=0, description=\"Posición destino (>= 0)\")\nclass CardOut(BaseModel):",
        "detail": "backend.app.cards.schemas",
        "documentation": {}
    },
    {
        "label": "CardOut",
        "kind": 6,
        "importPath": "backend.app.cards.schemas",
        "description": "backend.app.cards.schemas",
        "peekOfCode": "class CardOut(BaseModel):\n    \"\"\"\n    Esquema de salida (read/model) que representa una tarjeta tal como se devuelve desde la API.\n    Campos:\n    - id (int): Identificador único de la tarjeta.\n    - board_id (int): Identificador del tablero al que pertenece la tarjeta.\n    - list_id (int): Identificador de la lista contenedora.\n    - title (str): Título de la tarjeta.\n    - description (Optional[str]): Descripción de la tarjeta.\n    - due_date (Optional[date]): Fecha límite (solo fecha).",
        "detail": "backend.app.cards.schemas",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "backend.app.config",
        "description": "backend.app.config",
        "peekOfCode": "class Settings(BaseSettings):\n    # Database\n    DATABASE_URL: str = \"sqlite:///./test.db\"\n    # JWT\n    SECRET_KEY: str = \"your-secret-key-here\"\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    model_config = ConfigDict(\n        env_file=\".env\" if os.getenv(\"TESTING\") != \"1\" else None\n    )",
        "detail": "backend.app.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "backend.app.config",
        "description": "backend.app.config",
        "peekOfCode": "settings = Settings()",
        "detail": "backend.app.config",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "DATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://postgres:niki2025@localhost:5432/neocare_db\"\n)\n# Crea el motor de conexión con SQLAlchemy\nengine = create_engine(\n    DATABASE_URL,\n    future=True,\n    echo=True,  # Muestra las consultas SQL generadas (útil para desarrollo y depuración)\n    connect_args={\"client_encoding\": \"utf8\"}",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "engine = create_engine(\n    DATABASE_URL,\n    future=True,\n    echo=True,  # Muestra las consultas SQL generadas (útil para desarrollo y depuración)\n    connect_args={\"client_encoding\": \"utf8\"}\n)\n# Genera la clase de sesión para interactuar con la base de datos\nSessionLocal = sessionmaker(\n    autocommit=False,           # Las transacciones no se confirman automáticamente\n    autoflush=False,            # No se realiza autoflush en los cambios",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "SessionLocal = sessionmaker(\n    autocommit=False,           # Las transacciones no se confirman automáticamente\n    autoflush=False,            # No se realiza autoflush en los cambios\n    bind=engine                 # No se realiza autoflush en los cambios\n)\n# Clase base para los modelos ORM\nBase = declarative_base()",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "Base = declarative_base()",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 2,
        "importPath": "backend.app.main",
        "description": "backend.app.main",
        "peekOfCode": "def root():\n    \"\"\"\n    Endpoint raíz (health check).\n    Permite verificar si el backend de NeoCare está operativo.\n    \"\"\"\n    return {\"status\": \"NeoCare Backend Running\"}",
        "detail": "backend.app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend.app.main",
        "description": "backend.app.main",
        "peekOfCode": "app = FastAPI(title=\"NeoCare API\")\n# CORS (para que el frontend pueda llamar al backend)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # ¡En producción, define los dominios permitidos!\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n# Registra las rutas",
        "detail": "backend.app.main",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "backend.auth.routes",
        "description": "backend.auth.routes",
        "peekOfCode": "def register(user: UserRegister, db: Session = Depends(get_db)):\n    exists = db.query(models.User).filter(\n        (models.User.username == user.username) |\n        (models.User.email == user.email)\n    ).first()\n    if exists:\n        raise HTTPException(status_code=400, detail=\"Usuario o email ya registrado\")\n    hashed = hash_password(user.password)\n    new_user = models.User(\n        username=user.username,",
        "detail": "backend.auth.routes",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "backend.auth.routes",
        "description": "backend.auth.routes",
        "peekOfCode": "def login(credentials: UserLogin, db: Session = Depends(get_db)):\n    user = db.query(models.User).filter(models.User.username == credentials.username).first()\n    if not user or not verify_password(credentials.password, user.hashed_password):\n        raise HTTPException(status_code=401, detail=\"Credenciales incorrectas\")\n    token = create_token({\"sub\": user.username})\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n# ---------- GET CURRENT USER ----------\ndef get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):\n    payload = verify_token(token)\n    if not payload:",
        "detail": "backend.auth.routes",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "kind": 2,
        "importPath": "backend.auth.routes",
        "description": "backend.auth.routes",
        "peekOfCode": "def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):\n    payload = verify_token(token)\n    if not payload:\n        raise HTTPException(status_code=401, detail=\"Token inválido\")\n    username = payload.get(\"sub\")\n    user = db.query(models.User).filter(models.User.username == username).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n    return user",
        "detail": "backend.auth.routes",
        "documentation": {}
    },
    {
        "label": "oauth2_scheme",
        "kind": 5,
        "importPath": "backend.auth.routes",
        "description": "backend.auth.routes",
        "peekOfCode": "oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\nauth_router = APIRouter()\n# ---------- REGISTER ----------\n@auth_router.post(\"/register\", response_model=UserOut)\ndef register(user: UserRegister, db: Session = Depends(get_db)):\n    exists = db.query(models.User).filter(\n        (models.User.username == user.username) |\n        (models.User.email == user.email)\n    ).first()\n    if exists:",
        "detail": "backend.auth.routes",
        "documentation": {}
    },
    {
        "label": "auth_router",
        "kind": 5,
        "importPath": "backend.auth.routes",
        "description": "backend.auth.routes",
        "peekOfCode": "auth_router = APIRouter()\n# ---------- REGISTER ----------\n@auth_router.post(\"/register\", response_model=UserOut)\ndef register(user: UserRegister, db: Session = Depends(get_db)):\n    exists = db.query(models.User).filter(\n        (models.User.username == user.username) |\n        (models.User.email == user.email)\n    ).first()\n    if exists:\n        raise HTTPException(status_code=400, detail=\"Usuario o email ya registrado\")",
        "detail": "backend.auth.routes",
        "documentation": {}
    },
    {
        "label": "UserRegister",
        "kind": 6,
        "importPath": "backend.auth.schemas",
        "description": "backend.auth.schemas",
        "peekOfCode": "class UserRegister(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\nclass UserLogin(BaseModel):\n    username: str\n    password: str\nclass UserOut(BaseModel):\n    id: int\n    username: str",
        "detail": "backend.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserLogin",
        "kind": 6,
        "importPath": "backend.auth.schemas",
        "description": "backend.auth.schemas",
        "peekOfCode": "class UserLogin(BaseModel):\n    username: str\n    password: str\nclass UserOut(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    class Config:\n        orm_mode = True\nclass Token(BaseModel):",
        "detail": "backend.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserOut",
        "kind": 6,
        "importPath": "backend.auth.schemas",
        "description": "backend.auth.schemas",
        "peekOfCode": "class UserOut(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    class Config:\n        orm_mode = True\nclass Token(BaseModel):\n    access_token: str\n    token_type: str",
        "detail": "backend.auth.schemas",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "backend.auth.schemas",
        "description": "backend.auth.schemas",
        "peekOfCode": "class Token(BaseModel):\n    access_token: str\n    token_type: str",
        "detail": "backend.auth.schemas",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "kind": 2,
        "importPath": "backend.auth.utils",
        "description": "backend.auth.utils",
        "peekOfCode": "def hash_password(password: str):\n    return pwd_context.hash(password)\ndef verify_password(plain, hashed):\n    return pwd_context.verify(plain, hashed)\ndef create_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\ndef verify_token(token: str):",
        "detail": "backend.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "backend.auth.utils",
        "description": "backend.auth.utils",
        "peekOfCode": "def verify_password(plain, hashed):\n    return pwd_context.verify(plain, hashed)\ndef create_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\ndef verify_token(token: str):\n    try:\n        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])",
        "detail": "backend.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_token",
        "kind": 2,
        "importPath": "backend.auth.utils",
        "description": "backend.auth.utils",
        "peekOfCode": "def create_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\ndef verify_token(token: str):\n    try:\n        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    except JWTError:\n        return None",
        "detail": "backend.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "kind": 2,
        "importPath": "backend.auth.utils",
        "description": "backend.auth.utils",
        "peekOfCode": "def verify_token(token: str):\n    try:\n        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    except JWTError:\n        return None",
        "detail": "backend.auth.utils",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "backend.auth.utils",
        "description": "backend.auth.utils",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef hash_password(password: str):\n    return pwd_context.hash(password)\ndef verify_password(plain, hashed):\n    return pwd_context.verify(plain, hashed)\ndef create_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)",
        "detail": "backend.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_board",
        "kind": 2,
        "importPath": "backend.boards.routes",
        "description": "backend.boards.routes",
        "peekOfCode": "def create_board(board: BoardBase, db: Session = Depends(get_db), user=Depends(get_current_user)):\n    new_board = models.Board(title=board.title, owner_id=user.id)\n    db.add(new_board)\n    db.commit()\n    db.refresh(new_board)\n    return new_board\n@boards_router.get(\"/\", response_model=list[BoardOut])\ndef get_user_boards(db: Session = Depends(get_db), user=Depends(get_current_user)):\n    return db.query(models.Board).filter(models.Board.owner_id == user.id).all()\n@boards_router.delete(\"/{board_id}\")",
        "detail": "backend.boards.routes",
        "documentation": {}
    },
    {
        "label": "get_user_boards",
        "kind": 2,
        "importPath": "backend.boards.routes",
        "description": "backend.boards.routes",
        "peekOfCode": "def get_user_boards(db: Session = Depends(get_db), user=Depends(get_current_user)):\n    return db.query(models.Board).filter(models.Board.owner_id == user.id).all()\n@boards_router.delete(\"/{board_id}\")\ndef delete_board(board_id: int, db: Session = Depends(get_db), user=Depends(get_current_user)):\n    board = db.query(models.Board).filter(\n        models.Board.id == board_id,\n        models.Board.owner_id == user.id\n    ).first()\n    if not board:\n        raise HTTPException(status_code=404, detail=\"Board no encontrado\")",
        "detail": "backend.boards.routes",
        "documentation": {}
    },
    {
        "label": "delete_board",
        "kind": 2,
        "importPath": "backend.boards.routes",
        "description": "backend.boards.routes",
        "peekOfCode": "def delete_board(board_id: int, db: Session = Depends(get_db), user=Depends(get_current_user)):\n    board = db.query(models.Board).filter(\n        models.Board.id == board_id,\n        models.Board.owner_id == user.id\n    ).first()\n    if not board:\n        raise HTTPException(status_code=404, detail=\"Board no encontrado\")\n    db.delete(board)\n    db.commit()\n    return {\"message\": \"Board eliminado\"}",
        "detail": "backend.boards.routes",
        "documentation": {}
    },
    {
        "label": "boards_router",
        "kind": 5,
        "importPath": "backend.boards.routes",
        "description": "backend.boards.routes",
        "peekOfCode": "boards_router = APIRouter()\n@boards_router.post(\"/\", response_model=BoardOut)\ndef create_board(board: BoardBase, db: Session = Depends(get_db), user=Depends(get_current_user)):\n    new_board = models.Board(title=board.title, owner_id=user.id)\n    db.add(new_board)\n    db.commit()\n    db.refresh(new_board)\n    return new_board\n@boards_router.get(\"/\", response_model=list[BoardOut])\ndef get_user_boards(db: Session = Depends(get_db), user=Depends(get_current_user)):",
        "detail": "backend.boards.routes",
        "documentation": {}
    },
    {
        "label": "BoardBase",
        "kind": 6,
        "importPath": "backend.boards.schemas",
        "description": "backend.boards.schemas",
        "peekOfCode": "class BoardBase(BaseModel):\n    title: str\nclass BoardOut(BoardBase):\n    id: int\n    owner_id: int\n    class Config:\n        orm_mode = True",
        "detail": "backend.boards.schemas",
        "documentation": {}
    },
    {
        "label": "BoardOut",
        "kind": 6,
        "importPath": "backend.boards.schemas",
        "description": "backend.boards.schemas",
        "peekOfCode": "class BoardOut(BoardBase):\n    id: int\n    owner_id: int\n    class Config:\n        orm_mode = True",
        "detail": "backend.boards.schemas",
        "documentation": {}
    },
    {
        "label": "test_register_success",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_register_success(mock_create_token, mock_hash_password):\n    \"\"\"Verifica el flujo de registro exitoso.\n    Preparación:\n    - Se simula una sesión de DB (mock_session) cuya consulta no encuentra un usuario existente.\n    - Se sobrescribe la dependencia get_db para devolver la mock_session.\n    - Se parchean hash_password y create_token para devolver valores controlados.\n    Flujo:\n    1. POST a /auth/register con user_data.\n    2. Comprobar que la respuesta es 200 y contiene el token esperado.\n    Aserciones:",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_register_existing_email",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_register_existing_email(mock_get_db):\n    \"\"\"Verifica que registrar con un email ya existente devuelve error 400.\n    Preparación:\n    - mock_get_db devuelve una sesión simulada cuya consulta encuentra un usuario existente.\n    Flujo:\n    1. POST a /auth/register con user_data.\n    2. Comprobar que la respuesta es 400 con detalle \"Email ya registrado\".\n    Aserciones:\n    - status_code == 400\n    - response.json()[\"detail\"] == \"Email ya registrado\"",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_login_success",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_login_success(mock_create_token, mock_verify_password, mock_get_db):\n    \"\"\"Verifica el inicio de sesión exitoso y la emisión de un token.\n    Preparación:\n    - Se crea una sesión simulada que devuelve un usuario con password_hash.\n    - Se parchea verify_password para devolver True y create_token para devolver un token falso.\n    Flujo:\n    1. POST a /auth/login con login_data.\n    2. Comprobar que la respuesta es 200 y el JSON contiene access_token y token_type.\n    Aserciones:\n    - status_code == 200",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_login_invalid_credentials",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_login_invalid_credentials(mock_verify_password, mock_get_db):\n    \"\"\"Verifica que credenciales inválidas retornan 401.\n    Preparación:\n    - La sesión simulada devuelve un usuario pero verify_password se patcha para devolver False.\n    Flujo:\n    1. POST a /auth/login con login_data.\n    2. Comprobar que la respuesta es 401 y el detalle indica credenciales incorrectas.\n    Aserciones:\n    - status_code == 401\n    - response.json()[\"detail\"] == \"Credenciales incorrectas\"",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "client = TestClient(app)\nuser_data = {\"email\": \"test@example.com\", \"password\": \"password123\", \"name\": \"Test User\"}\nlogin_data = {\"email\": \"test@example.com\", \"password\": \"password123\"}\nfake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "user_data = {\"email\": \"test@example.com\", \"password\": \"password123\", \"name\": \"Test User\"}\nlogin_data = {\"email\": \"test@example.com\", \"password\": \"password123\"}\nfake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.\n- test_register_existing_email: intenta registrar con un email ya existente y espera error 400.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "login_data",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "login_data = {\"email\": \"test@example.com\", \"password\": \"password123\"}\nfake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.\n- test_register_existing_email: intenta registrar con un email ya existente y espera error 400.\n- test_login_success: inicia sesión con credenciales válidas y devuelve un token.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "fake_token",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "fake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.\n- test_register_existing_email: intenta registrar con un email ya existente y espera error 400.\n- test_login_success: inicia sesión con credenciales válidas y devuelve un token.\n- test_login_invalid_credentials: inicio de sesión con password inválida y devuelve 401.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_user_register_valido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_register_valido():\n    \"\"\"Comprueba que UserRegister acepta datos válidos.\n    Flujo:\n    1. Crear instancia UserRegister con email, password y name válidos.\n    2. Comprobar que los atributos se asignan correctamente.\n    Aserciones:\n    - user.email, user.password y user.name coinciden con los valores proporcionados.\n    \"\"\"\n    user = UserRegister(email=\"test@example.com\", password=\"password123\", name=\"Test User\")\n    assert user.email == \"test@example.com\"",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_register_sin_name",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_register_sin_name():\n    \"\"\"Verifica que el campo `name` es opcional en UserRegister.\n    Flujo:\n    1. Crear instancia UserRegister sin proporcionar `name`.\n    2. Comprobar que el campo `name` queda en None por defecto.\n    Aserciones:\n    - user.name es None cuando no se suministra.\n    \"\"\"\n    user = UserRegister(email=\"user2@example.com\", password=\"password123\")\n    assert user.name is None  # El campo opcional debe ser None por defecto",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_register_email_invalido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_register_email_invalido():\n    \"\"\"Asegura que UserRegister valida el formato de email usando Pydantic.\n    Flujo:\n    1. Intentar crear UserRegister con un email inválido.\n    2. Esperar que Pydantic lance ValidationError.\n    Aserciones:\n    - Se lanza ValidationError para emails con formato incorrecto.\n    \"\"\"\n    with pytest.raises(ValidationError):\n        UserRegister(email=\"correo-invalido\", password=\"password123\", name=\"Test User\")",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_login_valido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_login_valido():\n    \"\"\"Comprueba que UserLogin acepta credenciales válidas.\n    Flujo:\n    1. Crear instancia UserLogin con email y password válidos.\n    2. Verificar los atributos resultantes.\n    Aserciones:\n    - user.email y user.password coinciden con los valores proporcionados.\n    \"\"\"\n    user = UserLogin(email=\"login@example.com\", password=\"password123\")\n    assert user.email == \"login@example.com\"",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_login_email_invalido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_login_email_invalido():\n    \"\"\"Verifica que UserLogin valida el formato de email y lanza ValidationError si es inválido.\n    Flujo:\n    1. Intentar crear UserLogin con email mal formado.\n    2. Esperar ValidationError de Pydantic.\n    Aserciones:\n    - Se lanza ValidationError para el email inválido.\n    \"\"\"\n    with pytest.raises(ValidationError):\n        UserLogin(email=\"login-invalido\", password=\"password123\")",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_token_valido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_token_valido():\n    \"\"\"Comprueba la creación de Token con valores por defecto.\n    Flujo:\n    1. Crear Token con access_token.\n    2. Verificar que access_token se asigna y token_type toma el valor por defecto.\n    Aserciones:\n    - token.access_token coincide con el valor proporcionado.\n    - token.token_type es 'bearer' por defecto.\n    \"\"\"\n    token = Token(access_token=\"fake.jwt.token\")",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_token_tipo_personalizado",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_token_tipo_personalizado():\n    \"\"\"Verifica que Token acepta un token_type personalizado.\n    Flujo:\n    1. Crear Token indicando token_type distinto al por defecto.\n    2. Comprobar que el token_type se guarda correctamente.\n    Aserciones:\n    - token.token_type coincide con el valor personalizado pasado.\n    \"\"\"\n    token = Token(access_token=\"fake.jwt.token\", token_type=\"custom\")\n    assert token.token_type == \"custom\"",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_hash_y_verify_password",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_hash_y_verify_password():\n    \"\"\"Verifica que hash_password genera un hash distinto y que verify_password\n    valida correctamente la contraseña original y niega contraseñas incorrectas.\n    Comportamiento esperado:\n    - El resultado de hash_password no debe ser igual a la contraseña en plano.\n    - verify_password devuelve True para la contraseña correcta.\n    - verify_password devuelve False para una contraseña incorrecta.\n    \"\"\"\n    password = \"mi_password_seguro\"\n    hashed = hash_password(password)",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_hash_password_none",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_hash_password_none():\n    \"\"\"Verifica que pasar None a hash_password devuelve un string válido y que\n    verify_password trata None (convertido a cadena vacía) de forma consistente.\n    Comportamiento esperado:\n    - hash_password(None) devuelve un str.\n    - verify_password con cadena vacía y ese hash debe devolver True si la\n      implementación normaliza None a \"\".\n    \"\"\"\n    hashed = hash_password(None)\n    assert isinstance(hashed, str)",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_create_token_contenido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_create_token_contenido():\n    \"\"\"Verifica que create_token incorpora correctamente el payload en el JWT.\n    Comportamiento esperado:\n    - El token decodificado contiene las claves del payload (user_id, email).\n    - Contiene la reclamación 'exp' (expiración).\n    - Se utiliza SECRET_KEY y ALGORITHM para decodificar el token.\n    \"\"\"\n    data = {\"user_id\": 1, \"email\": \"test@example.com\"}\n    token = create_token(data)\n    decoded = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_get_current_user_exitoso",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_get_current_user_exitoso(mock_jwt_decode, mock_session_local):\n    \"\"\"Simula un token válido y una sesión de BD que devuelve un usuario.\n    Preparación:\n    - mock_jwt_decode devuelve un payload con 'user_id'.\n    - mock_session_local y la sesión resultante devuelven un mock_user en la consulta.\n    Comportamiento esperado:\n    - get_current_user devuelve el usuario obtenido de la BD.\n    - jwt.decode fue invocado para procesar el token.\n    \"\"\"\n    # Mock del payload decodificado",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_get_current_user_token_invalido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_get_current_user_token_invalido():\n    \"\"\"Verifica que get_current_user lanza una excepción cuando el token es inválido.\n    Preparación:\n    - jwt.decode parcheado para lanzar JWTError.\n    Comportamiento esperado:\n    - Se lanza una excepción que contiene el mensaje indicativo de token inválido o expirado.\n    \"\"\"\n    # JWTError simulado\n    with patch(\"app.auth.utils.jwt.decode\", side_effect=JWTError):\n        with pytest.raises(Exception) as excinfo:",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_get_current_user_usuario_no_existe",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_get_current_user_usuario_no_existe():\n    \"\"\"Verifica que get_current_user lanza excepción si el token es válido pero el usuario no existe.\n    Preparación:\n    - jwt.decode devuelve payload con 'user_id'.\n    - la consulta a la BD devuelve None (usuario no encontrado).\n    Comportamiento esperado:\n    - Se lanza una excepción con mensaje indicando token inválido o expirado (o usuario no encontrado).\n    \"\"\"\n    # Token válido pero DB no devuelve usuario\n    with patch(\"app.auth.utils.jwt.decode\", return_value={\"user_id\": 1}):",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "setup_db",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def setup_db():\n    \"\"\"Fixture que prepara una base de datos SQLite en memoria para las pruebas.\n    Crea todas las tablas definidas en Base.metadata antes de ceder la sesión de prueba,\n    proporciona una sesión de SQLAlchemy (TestingSessionLocal) a las pruebas y realiza\n    el teardown al cerrar la sesión y eliminar las tablas al final del módulo.\n    Returns:\n        Session: sesión de SQLAlchemy ligada a la base de datos de prueba.\n    \"\"\"\n    # Crear tablas\n    Base.metadata.create_all(bind=engine)",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_user",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_user(setup_db):\n    \"\"\"Comprueba que se puede crear y persistir un User en la base de datos de prueba.\n    Flujo:\n    1. Crear una instancia User y añadirla a la sesión.\n    2. Commit y refresh para obtener campos generados (p.ej. id).\n    Aserciones:\n    - user.id se ha generado (no es None).\n    - user.email y user.name coinciden con los valores proporcionados.\n    \"\"\"\n    db = setup_db",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_board",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_board(setup_db):\n    \"\"\"Verifica la creación de un Board asociado a un User (owner).\n    Flujo:\n    1. Crear y persistir un User.\n    2. Crear un Board asignándole owner y user_id.\n    3. Commit y refresh del Board.\n    Aserciones:\n    - board.id se ha generado.\n    - board.owner referencia al usuario creado.\n    - board.name coincide con el valor esperado.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_list",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_list(setup_db):\n    \"\"\"Verifica la creación de una List (lista de tareas) asociada a un Board.\n    Flujo:\n    1. Crear y persistir un User.\n    2. Crear y persistir un Board asociado al usuario.\n    3. Crear una List vinculada al Board y comprobar sus atributos.\n    Aserciones:\n    - list_.id se ha generado.\n    - list_.board referencia al board creado.\n    - list_.position coincide con el valor proporcionado.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_card",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_card(setup_db):\n    \"\"\"Comprueba la creación de una Card asociada a un Board, List y usuarios responsables.\n    Flujo:\n    1. Crear y persistir un User.\n    2. Crear y persistir un Board y una List.\n    3. Crear una Card vinculada al Board y a la List; asignar created_by y responsible.\n    4. Commit y refresh del Card.\n    Aserciones:\n    - card.id se ha generado.\n    - card.board y card.list referencian las entidades creadas.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_time_entry",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_time_entry(setup_db):\n    \"\"\"Verifica la creación de una entrada de tiempo (TimeEntry) vinculada a un Card y un User.\n    Flujo:\n    1. Crear y persistir un User, Board, List y Card.\n    2. Crear un TimeEntry con fecha y horas y vincularlo al card y user.\n    3. Commit y refresh del TimeEntry.\n    Aserciones:\n    - entry.id se ha generado.\n    - entry.user y entry.card referencian las entidades creadas.\n    - entry.hours coincide con el valor insertado.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_board_member",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_board_member(setup_db):\n    \"\"\"Comprueba la creación de un BoardMember (miembro de tablero) y su asociación.\n    Flujo:\n    1. Crear y persistir un User y un Board.\n    2. Crear un BoardMember asociándolo al board y al user con un role.\n    3. Commit y refresh del BoardMember.\n    Aserciones:\n    - member.id se ha generado.\n    - member.board y member.user referencian las entidades creadas.\n    - member.role es el esperado (\"admin\").",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "engine = create_engine(\"sqlite:///:memory:\", echo=False)\nTestingSessionLocal = sessionmaker(bind=engine)\n@pytest.fixture(scope=\"module\")\ndef setup_db():\n    \"\"\"Fixture que prepara una base de datos SQLite en memoria para las pruebas.\n    Crea todas las tablas definidas en Base.metadata antes de ceder la sesión de prueba,\n    proporciona una sesión de SQLAlchemy (TestingSessionLocal) a las pruebas y realiza\n    el teardown al cerrar la sesión y eliminar las tablas al final del módulo.\n    Returns:\n        Session: sesión de SQLAlchemy ligada a la base de datos de prueba.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "TestingSessionLocal",
        "kind": 5,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "TestingSessionLocal = sessionmaker(bind=engine)\n@pytest.fixture(scope=\"module\")\ndef setup_db():\n    \"\"\"Fixture que prepara una base de datos SQLite en memoria para las pruebas.\n    Crea todas las tablas definidas en Base.metadata antes de ceder la sesión de prueba,\n    proporciona una sesión de SQLAlchemy (TestingSessionLocal) a las pruebas y realiza\n    el teardown al cerrar la sesión y eliminar las tablas al final del módulo.\n    Returns:\n        Session: sesión de SQLAlchemy ligada a la base de datos de prueba.\n    \"\"\"",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_get_boards_exitoso",
        "kind": 2,
        "importPath": "backend.tests.boards.test_routes_boards",
        "description": "backend.tests.boards.test_routes_boards",
        "peekOfCode": "def test_get_boards_exitoso():\n    \"\"\"Verifica que GET /boards/ devuelve los tableros del usuario autenticado.\n    Flujo de la prueba:\n    1. Crear un usuario falso (fake_user) con un id conocido.\n    2. Construir una lista de Board (fake_boards) asociadas a ese usuario.\n    3. Crear una sesión/ORM falsa (mock_session) cuyo .query(...).filter(...).all() devuelve fake_boards.\n    4. Sobrescribir las dependencias de FastAPI:\n    - get_current_user para que devuelva fake_user.\n    - get_db para que rinda mock_session.\n    5. Realizar una petición GET a /boards/ y validar la respuesta.",
        "detail": "backend.tests.boards.test_routes_boards",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.boards.test_routes_boards",
        "description": "backend.tests.boards.test_routes_boards",
        "peekOfCode": "client = TestClient(app)\n\"\"\"Pruebas de las rutas relacionadas con 'boards'.\nEste módulo contiene pruebas que verifican el comportamiento de la ruta GET /boards/\nutilizando TestClient de FastAPI y mocks para evitar dependencias externas (base de datos\ny autenticación real).\nDescripción y notas:\n- Se simula un usuario autenticado sobrescribiendo la dependencia get_current_user.\n- Se simula la sesión/consulta a la base de datos sobrescribiendo la dependencia get_db.\n- Las pruebas esperan resultados deterministas usando objetos Board creados en memoria.\n- Al final de cada prueba se limpia app.dependency_overrides para no afectar otras pruebas.",
        "detail": "backend.tests.boards.test_routes_boards",
        "documentation": {}
    },
    {
        "label": "crear_usuario_y_token",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def crear_usuario_y_token():\n    \"\"\"\n    Registra un usuario vía API y devuelve el usuario persistido en BD y su token.\n    Comportamiento:\n    - Genera un email único con uuid para evitar colisiones entre pruebas.\n    - Llama al endpoint /auth/register enviando email, password y name.\n    - Verifica que la respuesta HTTP sea 200 y extrae access_token del JSON.\n    - Recupera el usuario directamente desde la base de datos (SessionLocal).\n    - Cierra la sesión y devuelve (user, token).\n    Returns:",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "crear_board_y_lista",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def crear_board_y_lista(user):\n    \"\"\"\n    Crea directamente en la base de datos un Board y una List asociados a `user`.\n    Este helper no usa la API, sino que inserta registros via ORM para preparar\n    el estado necesario en las pruebas.\n    Args:\n        user (User): instancia ORM del usuario propietario del board.\n    Returns:\n        tuple(int, int): los IDs del tablero y de la lista creada.\n    Side effects:",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "crear_tarjeta_via_api",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def crear_tarjeta_via_api(board_id, list_id, headers):\n    \"\"\"\n    Crea una tarjeta llamando a POST /cards/ y devuelve el JSON de respuesta.\n    Args:\n        board_id (int): ID del tablero donde crear la tarjeta.\n        list_id (int): ID de la lista donde colocar la tarjeta.\n        headers (dict): cabeceras HTTP a enviar (por ejemplo Authorization).\n    Returns:\n        dict: JSON parseado devuelto por la API que representa la tarjeta creada.\n    Asserts:",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "mover_tarjeta_via_api",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def mover_tarjeta_via_api(card_id, list_id, order, headers):\n    \"\"\"\n    Mueve una tarjeta usando PATCH /cards/{id}/move.\n    Args:\n        card_id (int): ID de la tarjeta a mover.\n        list_id (int): ID de la lista destino.\n        order (int): nueva posición.\n        headers (dict): cabeceras HTTP con Authorization.\n    Returns:\n        dict: JSON devuelto por la API.",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_crear_tarjeta_ok",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_crear_tarjeta_ok():\n    \"\"\"\n    Caso feliz: un usuario registrado crea una tarjeta válida.\n    Flujo:\n    - Registrar usuario y obtener token.\n    - Crear board/list directamente en BD.\n    - Llamar a la API para crear la tarjeta.\n    - Comprobar que los campos devueltos coinciden y que la tarjeta existe en BD.\n    Aserciones clave:\n    - status 200 en creación.",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_crear_tarjeta_titulo_vacio",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_crear_tarjeta_titulo_vacio():\n    \"\"\"\n    Validación: intentar crear una tarjeta con título vacío debe fallar.\n    Verifica que Pydantic / validación del endpoint rechaza título vacío con 422.\n    \"\"\"\n    user, token = crear_usuario_y_token()\n    board_id, list_id = crear_board_y_lista(user)\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    payload = {\n        \"title\": \"\",  # título vacío",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_crear_tarjeta_fecha_invalida",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_crear_tarjeta_fecha_invalida():\n    \"\"\"\n    Validación: intentar crear una tarjeta con una fecha inválida debe fallar.\n    Se espera un 422 porque Pydantic no puede parsear la fecha proporcionada.\n    \"\"\"\n    user, token = crear_usuario_y_token()\n    board_id, list_id = crear_board_y_lista(user)\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    payload = {\n        \"title\": \"Fecha mala\",",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_editar_tarjeta_ok",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_editar_tarjeta_ok():\n    \"\"\"\n    Edición de tarjeta: crear una tarjeta y luego editar sus campos (title, description).\n    Flujo:\n    - Registrar usuario y obtener token.\n    - Preparar board/list y crear tarjeta vía API.\n    - Llamar PATCH /cards/{id} con los campos a actualizar.\n    - Verificar que la respuesta contiene los cambios y que la BD refleja los mismos.\n    \"\"\"\n    user, token = crear_usuario_y_token()",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_crear_tarjeta_sin_token",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_crear_tarjeta_sin_token():\n    \"\"\"\n    Intento de creación sin autenticación: debe devolver 401 (no autorizado).\n    No se envía cabecera Authorization y se espera que la API rechace la petición.\n    \"\"\"\n    # No enviamos Authorization en headers\n    payload = {\n        \"title\": \"Sin auth\",\n        \"board_id\": 1,\n        \"list_id\": 1,",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_ver_tarjeta_inexistente",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_ver_tarjeta_inexistente():\n    \"\"\"\n    Petición GET a una tarjeta inexistente: se espera 404.\n    \"\"\"\n    user, token = crear_usuario_y_token()\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = client.get(\"/cards/999999\", headers=headers)\n    assert resp.status_code == 404\ndef test_no_puede_ver_tarjeta_de_otro_usuario():\n    \"\"\"",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_no_puede_ver_tarjeta_de_otro_usuario",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_no_puede_ver_tarjeta_de_otro_usuario():\n    \"\"\"\n    Verificación de permisos entre usuarios:\n    - Crea Usuario A en la BD y le crea un board/list y una tarjeta asociada.\n    - Registra Usuario B vía API (para obtener token real).\n    - Usuario B intenta acceder a la tarjeta de A y debe obtener 403 o 404\n    (dependiendo de la implementación de permisos la API puede ocultar la\n    existencia con 404 o devolver 403 por falta de permiso).\n    \"\"\"\n    # Crear usuario A directamente en BD",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_flujo_completo_tarjeta",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_flujo_completo_tarjeta():\n    \"\"\"\n    Flujo funcional completo para una tarjeta:\n    1. Registro (login implícito) y obtención de token.\n    2. Creación de board/list y tarjeta.\n    3. Listado de tarjetas por board.\n    4. Edición de la tarjeta.\n    5. Verificación de los cambios a través de la API.\n    Aserciones:\n    - La tarjeta creada aparece en el listado filtrado por board_id.",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_mover_tarjeta_misma_lista",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_mover_tarjeta_misma_lista():\n    user, token = crear_usuario_y_token()\n    board_id, list_id = crear_board_y_lista(user)\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    # Crear 3 tarjetas\n    c1 = crear_tarjeta_via_api(board_id, list_id, headers)\n    c2 = crear_tarjeta_via_api(board_id, list_id, headers)\n    c3 = crear_tarjeta_via_api(board_id, list_id, headers)\n    # Mover la primera al final\n    mover_tarjeta_via_api(c1[\"id\"], list_id, 2, headers)",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_mover_tarjeta_a_otra_lista",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_mover_tarjeta_a_otra_lista():\n    user, token = crear_usuario_y_token()\n    board_id, list_a = crear_board_y_lista(user)\n    # Crear segunda lista\n    db = SessionLocal()\n    list_b = List(name=\"En progreso\", board_id=board_id, position=2)\n    db.add(list_b)\n    db.commit()\n    db.refresh(list_b)\n    db.close()",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_mover_tarjeta_sin_token",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_mover_tarjeta_sin_token():\n    resp = client.patch(\n        \"/cards/1/move\",\n        json={\"list_id\": 1, \"order\": 0},\n    )\n    assert resp.status_code == 401\n#CODIGO SEMANA 3\ndef test_mover_tarjeta_order_negativo():\n    user, token = crear_usuario_y_token()\n    board_id, list_id = crear_board_y_lista(user)",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "test_mover_tarjeta_order_negativo",
        "kind": 2,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "def test_mover_tarjeta_order_negativo():\n    user, token = crear_usuario_y_token()\n    board_id, list_id = crear_board_y_lista(user)\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    card = crear_tarjeta_via_api(board_id, list_id, headers)\n    resp = client.patch(\n        f\"/cards/{card['id']}/move\",\n        json={\"list_id\": list_id, \"order\": -1},\n        headers=headers,\n    )",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.cards.test_cards",
        "description": "backend.tests.cards.test_cards",
        "peekOfCode": "client = TestClient(app)\n# HELPERS \ndef crear_usuario_y_token():\n    \"\"\"\n    Registra un usuario vía API y devuelve el usuario persistido en BD y su token.\n    Comportamiento:\n    - Genera un email único con uuid para evitar colisiones entre pruebas.\n    - Llama al endpoint /auth/register enviando email, password y name.\n    - Verifica que la respuesta HTTP sea 200 y extrae access_token del JSON.\n    - Recupera el usuario directamente desde la base de datos (SessionLocal).",
        "detail": "backend.tests.cards.test_cards",
        "documentation": {}
    },
    {
        "label": "browser",
        "kind": 2,
        "importPath": "backend.tests.e2e.conftest",
        "description": "backend.tests.e2e.conftest",
        "peekOfCode": "def browser():\n    \"\"\"Crea una instancia del browser para toda la sesión.\"\"\"\n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=True)\n        yield browser\n        browser.close()\n@pytest.fixture(scope=\"function\")\ndef page(browser):\n    \"\"\"Crea una nueva página para cada test.\"\"\"\n    context = browser.new_context()",
        "detail": "backend.tests.e2e.conftest",
        "documentation": {}
    },
    {
        "label": "page",
        "kind": 2,
        "importPath": "backend.tests.e2e.conftest",
        "description": "backend.tests.e2e.conftest",
        "peekOfCode": "def page(browser):\n    \"\"\"Crea una nueva página para cada test.\"\"\"\n    context = browser.new_context()\n    page = context.new_page()\n    yield page\n    context.close()",
        "detail": "backend.tests.e2e.conftest",
        "documentation": {}
    },
    {
        "label": "test_user",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_user():\n    \"\"\"Genera un usuario único para toda la sesión.\"\"\"\n    unique = uuid.uuid4().hex[:8]\n    email = f\"e2e_{unique}@example.com\"\n    password = \"Password123!\"\n    token = _ensure_user(email, password)\n    return {\"email\": email, \"password\": password, \"token\": token}\n# ========================\n# TESTS DE BOARDS (GET)\n# ========================",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_get_boards",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_get_boards(test_user):\n    \"\"\"GET /boards/ - Obtiene los tableros del usuario\"\"\"\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    res = requests.get(f\"{BACKEND_URL}/boards/\", headers=headers, timeout=10)\n    assert res.status_code == 200, f\"Error al obtener boards: {res.text}\"\n    boards = res.json()\n    assert isinstance(boards, list), \"La respuesta debe ser una lista\"\n    assert len(boards) > 0, \"Debe haber al menos 1 board\"\n    # Guardar board_id para usar en otros tests\n    test_user[\"board_id\"] = boards[0][\"id\"]",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_get_lists",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_get_lists(test_user):\n    \"\"\"GET /boards/{board_id}/lists/ - Obtiene las listas del tablero\"\"\"\n    board_id = test_user.get(\"board_id\", 1)  # Usar el board del test anterior\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    res = requests.get(f\"{BACKEND_URL}/boards/{board_id}/lists/\", headers=headers, timeout=10)\n    assert res.status_code == 200, f\"Error al obtener lists: {res.text}\"\n    lists = res.json()\n    assert isinstance(lists, list), \"La respuesta debe ser una lista\"\n    assert len(lists) >= 3, \"Debe haber al menos 3 listas (Por hacer, En curso, Hecho)\"\n    # Guardar list_id para tests de cards",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_create_card",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_create_card(test_user):\n    \"\"\"POST /cards/ - Crear una nueva tarjeta\"\"\"\n    board_id = test_user.get(\"board_id\", 1)\n    list_id = test_user.get(\"list_id\", 1)\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    payload = {\n        \"title\": f\"Tarjeta E2E {int(time.time())}\",\n        \"description\": \"Descripción de prueba E2E\",\n        \"due_date\": \"2025-12-31\",\n        \"board_id\": board_id,",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_list_cards",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_list_cards(test_user):\n    \"\"\"GET /cards/?board_id={board_id} - Listar tarjetas del tablero\"\"\"\n    board_id = test_user.get(\"board_id\", 1)\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    res = requests.get(f\"{BACKEND_URL}/cards/?board_id={board_id}\", headers=headers, timeout=10)\n    assert res.status_code == 200, f\"Error al listar cards: {res.text}\"\n    cards = res.json()\n    assert isinstance(cards, list), \"La respuesta debe ser una lista\"\n    assert len(cards) > 0, \"Debe haber al menos 1 tarjeta\"\n    print(f\"✅ Cards listadas: {len(cards)} tarjetas\")",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_get_card_detail",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_get_card_detail(test_user):\n    \"\"\"GET /cards/{card_id} - Obtener detalle de una tarjeta\"\"\"\n    card_id = test_user.get(\"card_id\")\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    res = requests.get(f\"{BACKEND_URL}/cards/{card_id}\", headers=headers, timeout=10)\n    assert res.status_code == 200, f\"Error al obtener card: {res.text}\"\n    card = res.json()\n    assert card[\"id\"] == card_id, \"El ID debe coincidir\"\n    print(f\"✅ Card detalle obtenida: {card['title']}\")\ndef test_api_update_card_patch(test_user):",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_update_card_patch",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_update_card_patch(test_user):\n    \"\"\"PATCH /cards/{card_id} - Actualizar parcialmente una tarjeta\"\"\"\n    card_id = test_user.get(\"card_id\")\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    payload = {\"title\": \"Tarjeta Actualizada PATCH\"}\n    res = requests.patch(f\"{BACKEND_URL}/cards/{card_id}\", json=payload, headers=headers, timeout=10)\n    assert res.status_code == 200, f\"Error al actualizar card (PATCH): {res.text}\"\n    card = res.json()\n    assert card[\"title\"] == payload[\"title\"], \"El título debe estar actualizado\"\n    print(f\"✅ Card actualizada (PATCH): {card['title']}\")",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_update_card_put",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_update_card_put(test_user):\n    \"\"\"PUT /cards/{card_id} - Actualizar completamente una tarjeta\"\"\"\n    card_id = test_user.get(\"card_id\")\n    board_id = test_user.get(\"board_id\", 1)\n    list_id = test_user.get(\"list_id\", 1)\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    payload = {\n        \"title\": \"Tarjeta Actualizada PUT\",\n        \"description\": \"Nueva descripción completa\",\n        \"due_date\": \"2025-12-25\",",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_move_card",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_move_card(test_user):\n    \"\"\"PATCH /cards/{card_id}/move - Mover tarjeta a otra posición\"\"\"\n    card_id = test_user.get(\"card_id\")\n    list_id = test_user.get(\"list_id\", 1)\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    payload = {\"list_id\": list_id, \"order\": 0}\n    res = requests.patch(f\"{BACKEND_URL}/cards/{card_id}/move\", json=payload, headers=headers, timeout=10)\n    assert res.status_code == 200, f\"Error al mover card: {res.text}\"\n    print(f\"✅ Card movida correctamente\")\ndef test_api_delete_card(test_user):",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_api_delete_card",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_api_delete_card(test_user):\n    \"\"\"DELETE /cards/{card_id} - Eliminar una tarjeta\"\"\"\n    card_id = test_user.get(\"card_id\")\n    headers = {\"Authorization\": f\"Bearer {test_user['token']}\"}\n    res = requests.delete(f\"{BACKEND_URL}/cards/{card_id}\", headers=headers, timeout=10)\n    assert res.status_code == 204, f\"Error al eliminar card: {res.text}\"\n    # Verificar que ya no existe\n    get_res = requests.get(f\"{BACKEND_URL}/cards/{card_id}\", headers=headers, timeout=10)\n    assert get_res.status_code == 404, \"La tarjeta debería estar eliminada\"\n    print(f\"✅ Card eliminada correctamente\")",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "ui_login",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def ui_login(page, email: str, password: str):\n    \"\"\"Realiza login vía UI\"\"\"\n    page.goto(f\"{FRONTEND_URL}/login\")\n    page.fill(\"input[type=email]\", email)\n    page.fill(\"input[type=password]\", password)\n    page.click(\"button[type=submit]\")\n    page.wait_for_url(\"**/boards\")\ndef test_ui_login_exitoso(page, test_user):\n    \"\"\"Login correcto muestra el tablero\"\"\"\n    ui_login(page, test_user[\"email\"], test_user[\"password\"])",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_ui_login_exitoso",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_ui_login_exitoso(page, test_user):\n    \"\"\"Login correcto muestra el tablero\"\"\"\n    ui_login(page, test_user[\"email\"], test_user[\"password\"])\n    page.wait_for_selector(\"text=Por hacer\")\n    page.wait_for_selector(\"text=En curso\")\n    page.wait_for_selector(\"text=Hecho\")\n    print(\"✅ UI: Login exitoso y tablero cargado\")\ndef test_ui_login_fallido(page):\n    \"\"\"Login con credenciales inválidas muestra error\"\"\"\n    page.goto(f\"{FRONTEND_URL}/login\")",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_ui_login_fallido",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_ui_login_fallido(page):\n    \"\"\"Login con credenciales inválidas muestra error\"\"\"\n    page.goto(f\"{FRONTEND_URL}/login\")\n    page.fill(\"input[type=email]\", \"wrong@example.com\")\n    page.fill(\"input[type=password]\", \"badpass\")\n    page.click(\"button[type=submit]\")\n    page.wait_for_selector(\"text=No se ha podido iniciar sesión\")\n    print(\"✅ UI: Login fallido muestra error\")",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "FRONTEND_URL",
        "kind": 5,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "FRONTEND_URL = os.getenv(\"FRONTEND_URL\", \"http://localhost:5173\")\nBACKEND_URL = os.getenv(\"BACKEND_URL\", \"http://127.0.0.1:8000\")\ndef _ensure_user(email: str, password: str, name: str = \"E2E User\"):\n    \"\"\"Crea un usuario de prueba vía API.\"\"\"\n    payload = {\"email\": email, \"password\": password, \"name\": name}\n    res = requests.post(f\"{BACKEND_URL}/auth/register\", json=payload, timeout=10)\n    if res.status_code in [200, 201]:\n        return res.json().get(\"access_token\")\n    if res.status_code == 400 and \"Email ya registrado\" in res.text:\n        # Login si ya existe",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "BACKEND_URL",
        "kind": 5,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "BACKEND_URL = os.getenv(\"BACKEND_URL\", \"http://127.0.0.1:8000\")\ndef _ensure_user(email: str, password: str, name: str = \"E2E User\"):\n    \"\"\"Crea un usuario de prueba vía API.\"\"\"\n    payload = {\"email\": email, \"password\": password, \"name\": name}\n    res = requests.post(f\"{BACKEND_URL}/auth/register\", json=payload, timeout=10)\n    if res.status_code in [200, 201]:\n        return res.json().get(\"access_token\")\n    if res.status_code == 400 and \"Email ya registrado\" in res.text:\n        # Login si ya existe\n        login_res = requests.post(f\"{BACKEND_URL}/auth/login\", json={\"email\": email, \"password\": password}, timeout=10)",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_valores_por_defecto",
        "kind": 2,
        "importPath": "backend.tests.test_config",
        "description": "backend.tests.test_config",
        "peekOfCode": "def test_valores_por_defecto():\n    \"\"\"Comprueba los valores por defecto de la configuración.\n    Aserciones:\n    - DATABASE_URL tiene la ruta de prueba por defecto.\n    - SECRET_KEY, ALGORITHM y ACCESS_TOKEN_EXPIRE_MINUTES coinciden con los valores esperados.\n    \"\"\"\n    assert settings.DATABASE_URL == \"sqlite:///./test.db\"\n    assert settings.SECRET_KEY == \"your-secret-key-here\"\n    assert settings.ALGORITHM == \"HS256\"\n    assert settings.ACCESS_TOKEN_EXPIRE_MINUTES == 30",
        "detail": "backend.tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_carga_desde_env",
        "kind": 2,
        "importPath": "backend.tests.test_config",
        "description": "backend.tests.test_config",
        "peekOfCode": "def test_carga_desde_env(monkeypatch):\n    \"\"\"Verifica que Settings carga y parsea correctamente valores desde variables de entorno.\n    Flujo:\n    1. Establecer variables de entorno con monkeypatch.\n    2. Instanciar Settings y comprobar que los atributos reflejan las variables establecidas.\n    Aserciones:\n    - DATABASE_URL, SECRET_KEY y ALGORITHM coinciden con las variables de entorno.\n    - ACCESS_TOKEN_EXPIRE_MINUTES se convierte correctamente a entero (45).\n    \"\"\"\n    monkeypatch.setenv(\"DATABASE_URL\", \"sqlite:///./env_test.db\")",
        "detail": "backend.tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_database_url_definida",
        "kind": 2,
        "importPath": "backend.tests.test_database",
        "description": "backend.tests.test_database",
        "peekOfCode": "def test_database_url_definida():\n    \"\"\"Comprueba que la configuración expone DATABASE_URL y que tiene un esquema plausible.\n    Aserciones:\n    - DATABASE_URL no es None.\n    - El valor comienza con 'postgresql://' o 'sqlite://', esquemas esperados en la aplicación.\n    \"\"\"\n    assert DATABASE_URL is not None\n    assert DATABASE_URL.startswith(\"postgresql://\") or DATABASE_URL.startswith(\"sqlite://\")\n# ----------------------------\n# Test 2: Crear engine y session",
        "detail": "backend.tests.test_database",
        "documentation": {}
    },
    {
        "label": "test_engine_y_session_local",
        "kind": 2,
        "importPath": "backend.tests.test_database",
        "description": "backend.tests.test_database",
        "peekOfCode": "def test_engine_y_session_local():\n    \"\"\"Verifica que el engine y SessionLocal exportados por app.database son utilizables.\n    Flujo:\n    1. Comprueba que `engine` está definido.\n    2. Intenta crear una sesión usando SessionLocal y cerrar la sesión.\n    Aserciones:\n    - `engine` no es None.\n    - La sesión creada por SessionLocal se puede instanciar y cerrar sin errores.\n    \"\"\"\n    assert engine is not None",
        "detail": "backend.tests.test_database",
        "documentation": {}
    },
    {
        "label": "test_crear_tablas_temporales",
        "kind": 2,
        "importPath": "backend.tests.test_database",
        "description": "backend.tests.test_database",
        "peekOfCode": "def test_crear_tablas_temporales():\n    \"\"\"Crea un engine SQLite en memoria, genera las tablas definidas en Base y abre una sesión.\n    Flujo:\n    1. Crear un engine SQLite en memoria y un sessionmaker ligado a él.\n    2. Llamar a Base.metadata.create_all(bind=test_engine) para crear las tablas.\n    3. Abrir y cerrar una sesión para verificar que la configuración de metadatos y conexión funciona.\n    Aserciones:\n    - Se puede instanciar y cerrar una sesión sobre la base temporal sin errores.\n    \"\"\"\n    test_engine = create_engine(\"sqlite:///:memory:\", echo=False)",
        "detail": "backend.tests.test_database",
        "documentation": {}
    },
    {
        "label": "test_root_endpoint",
        "kind": 2,
        "importPath": "backend.tests.test_main",
        "description": "backend.tests.test_main",
        "peekOfCode": "def test_root_endpoint():\n    \"\"\"Comprueba que el endpoint raíz devuelve el estado esperado.\n    Flujo:\n    1. Realiza una petición GET a \"/\".\n    2. Verifica que el status code es 200.\n    3. Comprueba que el JSON devuelto coincide con {\"status\": \"NeoCare Backend Running\"}.\n    Aserciones:\n    - response.status_code == 200\n    - response.json() == {\"status\": \"NeoCare Backend Running\"}\n    \"\"\"",
        "detail": "backend.tests.test_main",
        "documentation": {}
    },
    {
        "label": "test_auth_router_included",
        "kind": 2,
        "importPath": "backend.tests.test_main",
        "description": "backend.tests.test_main",
        "peekOfCode": "def test_auth_router_included():\n    \"\"\"Verifica de forma indirecta que el router de autenticación está montado.\n    Flujo:\n    1. Realiza una petición GET a \"/auth\".\n    2. Como es probable que no exista un GET en la raíz del router auth, se acepta\n    que la respuesta sea 404 (no encontrado) o 405 (método no permitido).\n    Si el router no estuviera incluido, algunas configuraciones podrían también\n    devolver 404; por eso se comprueba que el código esté entre [404, 405].\n    Aserciones:\n    - response.status_code está en [404, 405]",
        "detail": "backend.tests.test_main",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.test_main",
        "description": "backend.tests.test_main",
        "peekOfCode": "client = TestClient(app)\n\"\"\"Pruebas básicas de los endpoints expuestos por la aplicación principal (app.main).\nEste módulo contiene tests ligeros que verifican:\n- El endpoint raíz (GET /) responde correctamente con el estado esperado.\n- Que el router de autenticación está registrado en la aplicación (comprobado mediante\nuna petición a la ruta base de auth que debería devolver 404 o 405 si no hay un GET definido).\nEstas pruebas usan TestClient de FastAPI para realizar peticiones HTTP en memoria.\n\"\"\"\n# ----------------------------\n# Test GET /",
        "detail": "backend.tests.test_main",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "backend.config",
        "description": "backend.config",
        "peekOfCode": "DATABASE_URL = os.getenv(\"DATABASE_URL\")\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"supersecret-jwt-key\")\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 60",
        "detail": "backend.config",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "backend.config",
        "description": "backend.config",
        "peekOfCode": "SECRET_KEY = os.getenv(\"SECRET_KEY\", \"supersecret-jwt-key\")\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 60",
        "detail": "backend.config",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "backend.config",
        "description": "backend.config",
        "peekOfCode": "ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 60",
        "detail": "backend.config",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "kind": 5,
        "importPath": "backend.config",
        "description": "backend.config",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MINUTES = 60",
        "detail": "backend.config",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "backend.database",
        "description": "backend.database",
        "peekOfCode": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "backend.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "backend.database",
        "description": "backend.database",
        "peekOfCode": "engine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)\nBase = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "backend.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "backend.database",
        "description": "backend.database",
        "peekOfCode": "SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)\nBase = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "backend.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "backend.database",
        "description": "backend.database",
        "peekOfCode": "Base = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "backend.database",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 2,
        "importPath": "backend.main",
        "description": "backend.main",
        "peekOfCode": "def root():\n    return {\"message\": \"API funcionando 🚀\"}\n# Rutas\napp.include_router(auth_router, prefix=\"/auth\", tags=[\"Auth\"])\napp.include_router(boards_router, prefix=\"/boards\", tags=[\"Boards\"])",
        "detail": "backend.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend.main",
        "description": "backend.main",
        "peekOfCode": "app = FastAPI(title=\"Backend con JWT y Boards\")\n@app.get(\"/\")\ndef root():\n    return {\"message\": \"API funcionando 🚀\"}\n# Rutas\napp.include_router(auth_router, prefix=\"/auth\", tags=[\"Auth\"])\napp.include_router(boards_router, prefix=\"/boards\", tags=[\"Boards\"])",
        "detail": "backend.main",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "backend.models",
        "description": "backend.models",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, nullable=False, index=True)\n    email = Column(String, unique=True, nullable=False, index=True)\n    hashed_password = Column(String, nullable=False)\n    boards = relationship(\"Board\", back_populates=\"owner\")\nclass Board(Base):\n    __tablename__ = \"boards\"\n    id = Column(Integer, primary_key=True, index=True)",
        "detail": "backend.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "kind": 6,
        "importPath": "backend.models",
        "description": "backend.models",
        "peekOfCode": "class Board(Base):\n    __tablename__ = \"boards\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n    owner = relationship(\"User\", back_populates=\"boards\")",
        "detail": "backend.models",
        "documentation": {}
    },
    {
        "label": "read_root",
        "kind": 2,
        "importPath": "backend.prueba",
        "description": "backend.prueba",
        "peekOfCode": "def read_root():\n    \"\"\"\nMódulo FastAPI de ejemplo simple.\nExpone dos endpoints:\n- \"/\"        : Mensaje de bienvenida y verificación de estado.\n- \"/items/{item_id}\" : Retorna información de un ítem usando parámetros de path y query.\n\"\"\"\n    return {\"message\": \"Hola Néstor, FastAPI ya está funcionando 🚀\"}\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str | None = None):",
        "detail": "backend.prueba",
        "documentation": {}
    },
    {
        "label": "read_item",
        "kind": 2,
        "importPath": "backend.prueba",
        "description": "backend.prueba",
        "peekOfCode": "def read_item(item_id: int, q: str | None = None):\n    \"\"\"\n    Obtiene la información de un ítem según su ID y parámetro opcional de búsqueda.\n    Args:\n        item_id (int): Identificador del ítem recibido desde la URL (path).\n        q (str, optional): Parámetro de consulta (query string) opcional.\n    Returns:\n        dict: Diccionario con el ID del ítem, query recibido y mensaje de prueba.\n    \"\"\"\n    return {",
        "detail": "backend.prueba",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend.prueba",
        "description": "backend.prueba",
        "peekOfCode": "app = FastAPI()\n@app.get(\"/\")\ndef read_root():\n    \"\"\"\nMódulo FastAPI de ejemplo simple.\nExpone dos endpoints:\n- \"/\"        : Mensaje de bienvenida y verificación de estado.\n- \"/items/{item_id}\" : Retorna información de un ítem usando parámetros de path y query.\n\"\"\"\n    return {\"message\": \"Hola Néstor, FastAPI ya está funcionando 🚀\"}",
        "detail": "backend.prueba",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "backend.test",
        "description": "backend.test",
        "peekOfCode": "def main():\n    r = requests.get(\"https://httpbin.org/get\")\n    print(r.status_code, r.headers.get(\"Content-Type\"))\nif __name__ == \"__main__\":\n    main()",
        "detail": "backend.test",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    }
]
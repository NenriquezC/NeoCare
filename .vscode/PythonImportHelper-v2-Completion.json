[
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "jwt",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "JWTError",
        "importPath": "jose",
        "description": "jose",
        "isExtraImport": true,
        "detail": "jose",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordBearer",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Date",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "DateTime",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Numeric",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UniqueConstraint",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app.main",
        "description": "app.main",
        "isExtraImport": true,
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "UserRegister",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserLogin",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "app.auth.schemas",
        "description": "app.auth.schemas",
        "isExtraImport": true,
        "detail": "app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_token",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "importPath": "app.auth.utils",
        "description": "app.auth.utils",
        "isExtraImport": true,
        "detail": "app.auth.utils",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Card",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "TimeEntry",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "BoardMember",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "importPath": "app.boards.models",
        "description": "app.boards.models",
        "isExtraImport": true,
        "detail": "app.boards.models",
        "documentation": {}
    },
    {
        "label": "Settings",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "backend.app.auth.routes",
        "description": "backend.app.auth.routes",
        "peekOfCode": "def register(user: UserRegister, db: Session = Depends(get_db)):\n    \"\"\"\n    Crea un usuario nuevo y retorna un token de acceso JWT.\n    Parámetros:\n        user (UserRegister): Datos de registro recibidos en el cuerpo de la petición.\n        db (Session): Sesión de base de datos proporcionada por FastAPI.\n    Retorna:\n        Token: Diccionario con el JWT generado y el tipo de token.\n    Excepciones:\n        HTTP 400: Si el email ya está registrado en el sistema.",
        "detail": "backend.app.auth.routes",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "backend.app.auth.routes",
        "description": "backend.app.auth.routes",
        "peekOfCode": "def login(user: UserLogin, db: Session = Depends(get_db)):\n    \"\"\"\n    Autentica un usuario existente y retorna un token JWT si las credenciales son correctas.\n    Parámetros:\n        user (UserLogin): Credenciales enviadas por el cliente.\n        db (Session): Sesión de base de datos proporcionada por FastAPI.\n    Retorna:\n        Token: Diccionario con el JWT generado y el tipo de token.\n    Excepciones:\n        HTTP 401: Si el email no existe o la contraseña no coincide.",
        "detail": "backend.app.auth.routes",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "backend.app.auth.routes",
        "description": "backend.app.auth.routes",
        "peekOfCode": "router = APIRouter(prefix=\"/auth\", tags=[\"auth\"])\n@router.post(\"/register\", response_model=Token)\ndef register(user: UserRegister, db: Session = Depends(get_db)):\n    \"\"\"\n    Crea un usuario nuevo y retorna un token de acceso JWT.\n    Parámetros:\n        user (UserRegister): Datos de registro recibidos en el cuerpo de la petición.\n        db (Session): Sesión de base de datos proporcionada por FastAPI.\n    Retorna:\n        Token: Diccionario con el JWT generado y el tipo de token.",
        "detail": "backend.app.auth.routes",
        "documentation": {}
    },
    {
        "label": "UserRegister",
        "kind": 6,
        "importPath": "backend.app.auth.schemas",
        "description": "backend.app.auth.schemas",
        "peekOfCode": "class UserRegister(BaseModel):\n    \"\"\"\n    Esquema para recibir datos de registro de usuario.\n    Campos:\n        email (EmailStr): Correo electrónico válido.\n        password (str): Contraseña del usuario.\n        name (str, opcional): Nombre del usuario.\n    \"\"\"\n    email: EmailStr\n    password: str",
        "detail": "backend.app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "UserLogin",
        "kind": 6,
        "importPath": "backend.app.auth.schemas",
        "description": "backend.app.auth.schemas",
        "peekOfCode": "class UserLogin(BaseModel):\n    \"\"\"\n    Esquema para datos de login (inicio de sesión).\n    Campos:\n        email (EmailStr): Correo electrónico válido.\n        password (str): Contraseña del usuario.\n    \"\"\"\n    email: EmailStr\n    password: str\nclass Token(BaseModel):",
        "detail": "backend.app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "backend.app.auth.schemas",
        "description": "backend.app.auth.schemas",
        "peekOfCode": "class Token(BaseModel):\n    \"\"\"\n    Esquema de respuesta para el token JWT.\n    Campos:\n        access_token (str): Token de acceso generado.\n        token_type (str): Tipo de autenticación (bearer por defecto).\n    \"\"\"\n    access_token: str\n    token_type: str = \"bearer\"",
        "detail": "backend.app.auth.schemas",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:\n        str: Contraseña encriptada/hasheada.\n    \"\"\"\n    if password is None:\n        password = \"\"",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def verify_password(plain: str, hashed: str) -> bool:\n    \"\"\"\n    Verifica que la contraseña en texto plano coincida con el hash almacenado.\n    Args:\n        plain (str): Contraseña en texto plano proporcionada por el usuario.\n        hashed (str): Contraseña hasheada almacenada en la base de datos.\n    Returns:\n        bool: True si coincide, False si no.\n    \"\"\"\n    if plain is None:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "create_token",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def create_token(data: dict):\n    \"\"\"\n    Genera un token JWT codificando los datos de usuario.\n    Args:\n        data (dict): Datos a incluir en el payload del token.\n    Returns:\n        str: Token JWT generado.\n    \"\"\"\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MIN)",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def get_db():\n    \"\"\"\n    Genera una sesión nueva de base de datos para inyectar en rutas de FastAPI.\n    Yields:\n        Session: Sesión SQLAlchemy.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "kind": 2,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "def get_current_user(token: str = Depends(oauth2_scheme),db: Session = Depends(get_db)):\n    \"\"\"\n    Obtiene el usuario actual autenticado a partir del token JWT.\n    Args:\n        token (str): Token JWT extraído automáticamente por FastAPI.\n        db (Session): Sesión SQLAlchemy, inyectada.\n    Raises:\n        HTTPException: Si el token es inválido o el usuario no existe.\n    Returns:\n        User: Instancia del usuario autenticado en base de datos.",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "SECRET_KEY = \"CAMBIA_ESTA_CLAVE\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MIN = 60\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MIN = 60\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MIN",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MIN = 60\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "oauth2_scheme",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\npwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:\n        str: Contraseña encriptada/hasheada.",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "backend.app.auth.utils",
        "description": "backend.app.auth.utils",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"pbkdf2_sha256\"], deprecated=\"auto\")\n# ===== CONTRASEÑAS =====\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashea la contraseña del usuario utilizando el algoritmo pbkdf2_sha256.\n    Args:\n        password (str): Contraseña original en texto plano.\n    Returns:\n        str: Contraseña encriptada/hasheada.\n    \"\"\"",
        "detail": "backend.app.auth.utils",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class User(Base):\n    \"\"\"\n    Modelo de usuario del sistema.\n    Representa una cuenta con credenciales y relaciones hacia tableros,\n    tarjetas y registros de tiempo.\n    Campos principales:\n        id (int): Identificador único del usuario.\n        email (str): Correo único.\n        password_hash (str): Contraseña encriptada.\n        name (str): Nombre del usuario.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "Board",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class Board(Base):\n    \"\"\"\n    Modelo de tablero Kanban.\n    Representa un tablero donde los usuarios organizan listas y tarjetas.\n    Campos principales:\n        id (int): Identificador único de tablero.\n        name (str): Nombre del tablero.\n        user_id (int): Usuario propietario del tablero.\n        created_at (datetime): Fecha de creación.\n    Relaciones:",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class List(Base):\n    \"\"\"\n    Modelo de lista dentro de un tablero.\n    Permite agrupar tarjetas por proceso, etapa o categoría.\n    Campos principales:\n        id (int): Identificador único de la lista.\n        board_id (int): Tablero al que pertenece.\n        name (str): Nombre de la lista.\n        position (int): Posición en el tablero.\n        created_at (datetime): Fecha de creación.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "Card",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class Card(Base):\n    \"\"\"\n    Modelo de tarjeta/do Kanban.\n    Define tareas o ítems que pueden moverse entre listas y tableros.\n    Campos principales:\n        id (int): Identificador único de la tarjeta.\n        board_id, list_id (int): Relación con tablero y lista.\n        title (str): Título de la tarea.\n        description (Text): Descripción detallada.\n        due_date (Date): Fecha de entrega.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "TimeEntry",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class TimeEntry(Base):\n    \"\"\"\n    Registro de tiempo invertido en una tarjeta.\n    Permite cuantificar esfuerzos y generar historiales de trabajo.\n    Campos principales:\n        id (int): Identificador único.\n        user_id (int): Usuario que registró el tiempo.\n        card_id (int): Tarjeta asociada.\n        date (Date): Fecha del registro.\n        hours (Numeric): Horas trabajadas.",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "BoardMember",
        "kind": 6,
        "importPath": "backend.app.boards.models",
        "description": "backend.app.boards.models",
        "peekOfCode": "class BoardMember(Base):\n    \"\"\"\n    Asociación entre usuarios y tableros (membresías).\n    Permite controlar roles y accesos de los usuarios a los tableros.\n    Campos principales:\n        id (int): Identificador único.\n        board_id (int): Tablero asociado.\n        user_id (int): Usuario asociado.\n        role (str): Rol dentro del tablero.\n    Restricciones:",
        "detail": "backend.app.boards.models",
        "documentation": {}
    },
    {
        "label": "get_boards",
        "kind": 2,
        "importPath": "backend.app.boards.routes",
        "description": "backend.app.boards.routes",
        "peekOfCode": "def get_boards(db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Obtiene todos los tableros pertenecientes al usuario autenticado.\n    Parámetros:\n        db (Session): Sesión actual de la base de datos inyectada por FastAPI.\n        current_user (User): Usuario autenticado inyectado por FastAPI.\n    Retorna:\n        List[Board]: Lista de objetos Board que pertenecen al usuario actual.\n    \"\"\"\n    return db.query(Board).filter(Board.user_id == current_user.id).all()",
        "detail": "backend.app.boards.routes",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "backend.app.boards.routes",
        "description": "backend.app.boards.routes",
        "peekOfCode": "router = APIRouter(prefix=\"/boards\", tags=[\"boards\"])\n@router.get(\"/\")\ndef get_boards(db: Session = Depends(get_db),current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Obtiene todos los tableros pertenecientes al usuario autenticado.\n    Parámetros:\n        db (Session): Sesión actual de la base de datos inyectada por FastAPI.\n        current_user (User): Usuario autenticado inyectado por FastAPI.\n    Retorna:\n        List[Board]: Lista de objetos Board que pertenecen al usuario actual.",
        "detail": "backend.app.boards.routes",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "backend.app.config",
        "description": "backend.app.config",
        "peekOfCode": "class Settings(BaseSettings):\n    # Database\n    DATABASE_URL: str = \"sqlite:///./test.db\"\n    # JWT\n    SECRET_KEY: str = \"your-secret-key-here\"\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    class Config:\n        env_file = \".env\" if os.getenv(\"TESTING\") != \"1\" else None\nsettings = Settings()",
        "detail": "backend.app.config",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "backend.app.config",
        "description": "backend.app.config",
        "peekOfCode": "settings = Settings()",
        "detail": "backend.app.config",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "DATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://postgres:Limon1307@localhost:5432/neocare\"\n)\n# Crea el motor de conexión con SQLAlchemy\nengine = create_engine(\n    DATABASE_URL,\n    future=True,\n    echo=True  # Muestra las consultas SQL generadas (útil para desarrollo y depuración)\n)",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "engine = create_engine(\n    DATABASE_URL,\n    future=True,\n    echo=True  # Muestra las consultas SQL generadas (útil para desarrollo y depuración)\n)\n# Genera la clase de sesión para interactuar con la base de datos\nSessionLocal = sessionmaker(\n    autocommit=False,           # Las transacciones no se confirman automáticamente\n    autoflush=False,            # No se realiza autoflush en los cambios\n    bind=engine                 # No se realiza autoflush en los cambios",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "SessionLocal = sessionmaker(\n    autocommit=False,           # Las transacciones no se confirman automáticamente\n    autoflush=False,            # No se realiza autoflush en los cambios\n    bind=engine                 # No se realiza autoflush en los cambios\n)\n# Clase base para los modelos ORM\nBase = declarative_base()",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "backend.app.database",
        "description": "backend.app.database",
        "peekOfCode": "Base = declarative_base()",
        "detail": "backend.app.database",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 2,
        "importPath": "backend.app.main",
        "description": "backend.app.main",
        "peekOfCode": "def root():\n    \"\"\"\n    Endpoint raíz (health check).\n    Permite verificar si el backend de NeoCare está operativo.\n    \"\"\"\n    return {\"status\": \"NeoCare Backend Running\"}",
        "detail": "backend.app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend.app.main",
        "description": "backend.app.main",
        "peekOfCode": "app = FastAPI(title=\"NeoCare API\")\n# CORS (para que el frontend pueda llamar al backend)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],   #¡En producción, define los dominios permitidos!\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n# Registra las rutas de autenticación bajo el router correspondiente",
        "detail": "backend.app.main",
        "documentation": {}
    },
    {
        "label": "test_register_success",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_register_success(mock_create_token, mock_hash_password):\n    \"\"\"Verifica el flujo de registro exitoso.\n    Preparación:\n    - Se simula una sesión de DB (mock_session) cuya consulta no encuentra un usuario existente.\n    - Se sobrescribe la dependencia get_db para devolver la mock_session.\n    - Se parchean hash_password y create_token para devolver valores controlados.\n    Flujo:\n    1. POST a /auth/register con user_data.\n    2. Comprobar que la respuesta es 200 y contiene el token esperado.\n    Aserciones:",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_register_existing_email",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_register_existing_email(mock_get_db):\n    \"\"\"Verifica que registrar con un email ya existente devuelve error 400.\n    Preparación:\n    - mock_get_db devuelve una sesión simulada cuya consulta encuentra un usuario existente.\n    Flujo:\n    1. POST a /auth/register con user_data.\n    2. Comprobar que la respuesta es 400 con detalle \"Email ya registrado\".\n    Aserciones:\n    - status_code == 400\n    - response.json()[\"detail\"] == \"Email ya registrado\"",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_login_success",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_login_success(mock_create_token, mock_verify_password, mock_get_db):\n    \"\"\"Verifica el inicio de sesión exitoso y la emisión de un token.\n    Preparación:\n    - Se crea una sesión simulada que devuelve un usuario con password_hash.\n    - Se parchea verify_password para devolver True y create_token para devolver un token falso.\n    Flujo:\n    1. POST a /auth/login con login_data.\n    2. Comprobar que la respuesta es 200 y el JSON contiene access_token y token_type.\n    Aserciones:\n    - status_code == 200",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_login_invalid_credentials",
        "kind": 2,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "def test_login_invalid_credentials(mock_verify_password, mock_get_db):\n    \"\"\"Verifica que credenciales inválidas retornan 401.\n    Preparación:\n    - La sesión simulada devuelve un usuario pero verify_password se patcha para devolver False.\n    Flujo:\n    1. POST a /auth/login con login_data.\n    2. Comprobar que la respuesta es 401 y el detalle indica credenciales incorrectas.\n    Aserciones:\n    - status_code == 401\n    - response.json()[\"detail\"] == \"Credenciales incorrectas\"",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "client = TestClient(app)\nuser_data = {\"email\": \"test@example.com\", \"password\": \"password123\", \"name\": \"Test User\"}\nlogin_data = {\"email\": \"test@example.com\", \"password\": \"password123\"}\nfake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "user_data",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "user_data = {\"email\": \"test@example.com\", \"password\": \"password123\", \"name\": \"Test User\"}\nlogin_data = {\"email\": \"test@example.com\", \"password\": \"password123\"}\nfake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.\n- test_register_existing_email: intenta registrar con un email ya existente y espera error 400.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "login_data",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "login_data = {\"email\": \"test@example.com\", \"password\": \"password123\"}\nfake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.\n- test_register_existing_email: intenta registrar con un email ya existente y espera error 400.\n- test_login_success: inicia sesión con credenciales válidas y devuelve un token.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "fake_token",
        "kind": 5,
        "importPath": "backend.tests.auth.test_routes_auth",
        "description": "backend.tests.auth.test_routes_auth",
        "peekOfCode": "fake_token = \"fake.jwt.token\"\n\"\"\"\nPruebas de integración para las rutas de autenticación (/auth/register y /auth/login).\nEste módulo usa TestClient de FastAPI junto con patch/MagicMock para simular dependencias\ncomo la base de datos y las funciones de hashing/verificación de contraseñas y creación de tokens.\nDescripción general de las pruebas:\n- test_register_success: registra un usuario nuevo cuando no existe el email en DB.\n- test_register_existing_email: intenta registrar con un email ya existente y espera error 400.\n- test_login_success: inicia sesión con credenciales válidas y devuelve un token.\n- test_login_invalid_credentials: inicio de sesión con password inválida y devuelve 401.",
        "detail": "backend.tests.auth.test_routes_auth",
        "documentation": {}
    },
    {
        "label": "test_user_register_valido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_register_valido():\n    \"\"\"Comprueba que UserRegister acepta datos válidos.\n    Flujo:\n    1. Crear instancia UserRegister con email, password y name válidos.\n    2. Comprobar que los atributos se asignan correctamente.\n    Aserciones:\n    - user.email, user.password y user.name coinciden con los valores proporcionados.\n    \"\"\"\n    user = UserRegister(email=\"test@example.com\", password=\"password123\", name=\"Test User\")\n    assert user.email == \"test@example.com\"",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_register_sin_name",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_register_sin_name():\n    \"\"\"Verifica que el campo `name` es opcional en UserRegister.\n    Flujo:\n    1. Crear instancia UserRegister sin proporcionar `name`.\n    2. Comprobar que el campo `name` queda en None por defecto.\n    Aserciones:\n    - user.name es None cuando no se suministra.\n    \"\"\"\n    user = UserRegister(email=\"user2@example.com\", password=\"password123\")\n    assert user.name is None  # El campo opcional debe ser None por defecto",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_register_email_invalido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_register_email_invalido():\n    \"\"\"Asegura que UserRegister valida el formato de email usando Pydantic.\n    Flujo:\n    1. Intentar crear UserRegister con un email inválido.\n    2. Esperar que Pydantic lance ValidationError.\n    Aserciones:\n    - Se lanza ValidationError para emails con formato incorrecto.\n    \"\"\"\n    with pytest.raises(ValidationError):\n        UserRegister(email=\"correo-invalido\", password=\"password123\", name=\"Test User\")",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_login_valido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_login_valido():\n    \"\"\"Comprueba que UserLogin acepta credenciales válidas.\n    Flujo:\n    1. Crear instancia UserLogin con email y password válidos.\n    2. Verificar los atributos resultantes.\n    Aserciones:\n    - user.email y user.password coinciden con los valores proporcionados.\n    \"\"\"\n    user = UserLogin(email=\"login@example.com\", password=\"password123\")\n    assert user.email == \"login@example.com\"",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_user_login_email_invalido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_user_login_email_invalido():\n    \"\"\"Verifica que UserLogin valida el formato de email y lanza ValidationError si es inválido.\n    Flujo:\n    1. Intentar crear UserLogin con email mal formado.\n    2. Esperar ValidationError de Pydantic.\n    Aserciones:\n    - Se lanza ValidationError para el email inválido.\n    \"\"\"\n    with pytest.raises(ValidationError):\n        UserLogin(email=\"login-invalido\", password=\"password123\")",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_token_valido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_token_valido():\n    \"\"\"Comprueba la creación de Token con valores por defecto.\n    Flujo:\n    1. Crear Token con access_token.\n    2. Verificar que access_token se asigna y token_type toma el valor por defecto.\n    Aserciones:\n    - token.access_token coincide con el valor proporcionado.\n    - token.token_type es 'bearer' por defecto.\n    \"\"\"\n    token = Token(access_token=\"fake.jwt.token\")",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_token_tipo_personalizado",
        "kind": 2,
        "importPath": "backend.tests.auth.test_schemas",
        "description": "backend.tests.auth.test_schemas",
        "peekOfCode": "def test_token_tipo_personalizado():\n    \"\"\"Verifica que Token acepta un token_type personalizado.\n    Flujo:\n    1. Crear Token indicando token_type distinto al por defecto.\n    2. Comprobar que el token_type se guarda correctamente.\n    Aserciones:\n    - token.token_type coincide con el valor personalizado pasado.\n    \"\"\"\n    token = Token(access_token=\"fake.jwt.token\", token_type=\"custom\")\n    assert token.token_type == \"custom\"",
        "detail": "backend.tests.auth.test_schemas",
        "documentation": {}
    },
    {
        "label": "test_hash_y_verify_password",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_hash_y_verify_password():\n    \"\"\"Verifica que hash_password genera un hash distinto y que verify_password\n    valida correctamente la contraseña original y niega contraseñas incorrectas.\n    Comportamiento esperado:\n    - El resultado de hash_password no debe ser igual a la contraseña en plano.\n    - verify_password devuelve True para la contraseña correcta.\n    - verify_password devuelve False para una contraseña incorrecta.\n    \"\"\"\n    password = \"mi_password_seguro\"\n    hashed = hash_password(password)",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_hash_password_none",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_hash_password_none():\n    \"\"\"Verifica que pasar None a hash_password devuelve un string válido y que\n    verify_password trata None (convertido a cadena vacía) de forma consistente.\n    Comportamiento esperado:\n    - hash_password(None) devuelve un str.\n    - verify_password con cadena vacía y ese hash debe devolver True si la\n      implementación normaliza None a \"\".\n    \"\"\"\n    hashed = hash_password(None)\n    assert isinstance(hashed, str)",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_create_token_contenido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_create_token_contenido():\n    \"\"\"Verifica que create_token incorpora correctamente el payload en el JWT.\n    Comportamiento esperado:\n    - El token decodificado contiene las claves del payload (user_id, email).\n    - Contiene la reclamación 'exp' (expiración).\n    - Se utiliza SECRET_KEY y ALGORITHM para decodificar el token.\n    \"\"\"\n    data = {\"user_id\": 1, \"email\": \"test@example.com\"}\n    token = create_token(data)\n    decoded = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_get_current_user_exitoso",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_get_current_user_exitoso(mock_jwt_decode, mock_session_local):\n    \"\"\"Simula un token válido y una sesión de BD que devuelve un usuario.\n    Preparación:\n    - mock_jwt_decode devuelve un payload con 'user_id'.\n    - mock_session_local y la sesión resultante devuelven un mock_user en la consulta.\n    Comportamiento esperado:\n    - get_current_user devuelve el usuario obtenido de la BD.\n    - jwt.decode fue invocado para procesar el token.\n    \"\"\"\n    # Mock del payload decodificado",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_get_current_user_token_invalido",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_get_current_user_token_invalido():\n    \"\"\"Verifica que get_current_user lanza una excepción cuando el token es inválido.\n    Preparación:\n    - jwt.decode parcheado para lanzar JWTError.\n    Comportamiento esperado:\n    - Se lanza una excepción que contiene el mensaje indicativo de token inválido o expirado.\n    \"\"\"\n    # JWTError simulado\n    with patch(\"app.auth.utils.jwt.decode\", side_effect=JWTError):\n        with pytest.raises(Exception) as excinfo:",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "test_get_current_user_usuario_no_existe",
        "kind": 2,
        "importPath": "backend.tests.auth.test_utils",
        "description": "backend.tests.auth.test_utils",
        "peekOfCode": "def test_get_current_user_usuario_no_existe():\n    \"\"\"Verifica que get_current_user lanza excepción si el token es válido pero el usuario no existe.\n    Preparación:\n    - jwt.decode devuelve payload con 'user_id'.\n    - la consulta a la BD devuelve None (usuario no encontrado).\n    Comportamiento esperado:\n    - Se lanza una excepción con mensaje indicando token inválido o expirado (o usuario no encontrado).\n    \"\"\"\n    # Token válido pero DB no devuelve usuario\n    with patch(\"app.auth.utils.jwt.decode\", return_value={\"user_id\": 1}):",
        "detail": "backend.tests.auth.test_utils",
        "documentation": {}
    },
    {
        "label": "setup_db",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def setup_db():\n    \"\"\"Fixture que prepara una base de datos SQLite en memoria para las pruebas.\n    Crea todas las tablas definidas en Base.metadata antes de ceder la sesión de prueba,\n    proporciona una sesión de SQLAlchemy (TestingSessionLocal) a las pruebas y realiza\n    el teardown al cerrar la sesión y eliminar las tablas al final del módulo.\n    Returns:\n        Session: sesión de SQLAlchemy ligada a la base de datos de prueba.\n    \"\"\"\n    # Crear tablas\n    Base.metadata.create_all(bind=engine)",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_user",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_user(setup_db):\n    \"\"\"Comprueba que se puede crear y persistir un User en la base de datos de prueba.\n    Flujo:\n    1. Crear una instancia User y añadirla a la sesión.\n    2. Commit y refresh para obtener campos generados (p.ej. id).\n    Aserciones:\n    - user.id se ha generado (no es None).\n    - user.email y user.name coinciden con los valores proporcionados.\n    \"\"\"\n    db = setup_db",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_board",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_board(setup_db):\n    \"\"\"Verifica la creación de un Board asociado a un User (owner).\n    Flujo:\n    1. Crear y persistir un User.\n    2. Crear un Board asignándole owner y user_id.\n    3. Commit y refresh del Board.\n    Aserciones:\n    - board.id se ha generado.\n    - board.owner referencia al usuario creado.\n    - board.name coincide con el valor esperado.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_list",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_list(setup_db):\n    \"\"\"Verifica la creación de una List (lista de tareas) asociada a un Board.\n    Flujo:\n    1. Crear y persistir un User.\n    2. Crear y persistir un Board asociado al usuario.\n    3. Crear una List vinculada al Board y comprobar sus atributos.\n    Aserciones:\n    - list_.id se ha generado.\n    - list_.board referencia al board creado.\n    - list_.position coincide con el valor proporcionado.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_card",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_card(setup_db):\n    \"\"\"Comprueba la creación de una Card asociada a un Board, List y usuarios responsables.\n    Flujo:\n    1. Crear y persistir un User.\n    2. Crear y persistir un Board y una List.\n    3. Crear una Card vinculada al Board y a la List; asignar created_by y responsible.\n    4. Commit y refresh del Card.\n    Aserciones:\n    - card.id se ha generado.\n    - card.board y card.list referencian las entidades creadas.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_time_entry",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_time_entry(setup_db):\n    \"\"\"Verifica la creación de una entrada de tiempo (TimeEntry) vinculada a un Card y un User.\n    Flujo:\n    1. Crear y persistir un User, Board, List y Card.\n    2. Crear un TimeEntry con fecha y horas y vincularlo al card y user.\n    3. Commit y refresh del TimeEntry.\n    Aserciones:\n    - entry.id se ha generado.\n    - entry.user y entry.card referencian las entidades creadas.\n    - entry.hours coincide con el valor insertado.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_create_board_member",
        "kind": 2,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "def test_create_board_member(setup_db):\n    \"\"\"Comprueba la creación de un BoardMember (miembro de tablero) y su asociación.\n    Flujo:\n    1. Crear y persistir un User y un Board.\n    2. Crear un BoardMember asociándolo al board y al user con un role.\n    3. Commit y refresh del BoardMember.\n    Aserciones:\n    - member.id se ha generado.\n    - member.board y member.user referencian las entidades creadas.\n    - member.role es el esperado (\"admin\").",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "engine = create_engine(\"sqlite:///:memory:\", echo=False)\nTestingSessionLocal = sessionmaker(bind=engine)\n@pytest.fixture(scope=\"module\")\ndef setup_db():\n    \"\"\"Fixture que prepara una base de datos SQLite en memoria para las pruebas.\n    Crea todas las tablas definidas en Base.metadata antes de ceder la sesión de prueba,\n    proporciona una sesión de SQLAlchemy (TestingSessionLocal) a las pruebas y realiza\n    el teardown al cerrar la sesión y eliminar las tablas al final del módulo.\n    Returns:\n        Session: sesión de SQLAlchemy ligada a la base de datos de prueba.",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "TestingSessionLocal",
        "kind": 5,
        "importPath": "backend.tests.boards.test_models",
        "description": "backend.tests.boards.test_models",
        "peekOfCode": "TestingSessionLocal = sessionmaker(bind=engine)\n@pytest.fixture(scope=\"module\")\ndef setup_db():\n    \"\"\"Fixture que prepara una base de datos SQLite en memoria para las pruebas.\n    Crea todas las tablas definidas en Base.metadata antes de ceder la sesión de prueba,\n    proporciona una sesión de SQLAlchemy (TestingSessionLocal) a las pruebas y realiza\n    el teardown al cerrar la sesión y eliminar las tablas al final del módulo.\n    Returns:\n        Session: sesión de SQLAlchemy ligada a la base de datos de prueba.\n    \"\"\"",
        "detail": "backend.tests.boards.test_models",
        "documentation": {}
    },
    {
        "label": "test_get_boards_exitoso",
        "kind": 2,
        "importPath": "backend.tests.boards.test_routes_boards",
        "description": "backend.tests.boards.test_routes_boards",
        "peekOfCode": "def test_get_boards_exitoso():\n    \"\"\"Verifica que GET /boards/ devuelve los tableros del usuario autenticado.\n    Flujo de la prueba:\n    1. Crear un usuario falso (fake_user) con un id conocido.\n    2. Construir una lista de Board (fake_boards) asociadas a ese usuario.\n    3. Crear una sesión/ORM falsa (mock_session) cuyo .query(...).filter(...).all() devuelve fake_boards.\n    4. Sobrescribir las dependencias de FastAPI:\n    - get_current_user para que devuelva fake_user.\n    - get_db para que rinda mock_session.\n    5. Realizar una petición GET a /boards/ y validar la respuesta.",
        "detail": "backend.tests.boards.test_routes_boards",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.boards.test_routes_boards",
        "description": "backend.tests.boards.test_routes_boards",
        "peekOfCode": "client = TestClient(app)\n\"\"\"Pruebas de las rutas relacionadas con 'boards'.\nEste módulo contiene pruebas que verifican el comportamiento de la ruta GET /boards/\nutilizando TestClient de FastAPI y mocks para evitar dependencias externas (base de datos\ny autenticación real).\nDescripción y notas:\n- Se simula un usuario autenticado sobrescribiendo la dependencia get_current_user.\n- Se simula la sesión/consulta a la base de datos sobrescribiendo la dependencia get_db.\n- Las pruebas esperan resultados deterministas usando objetos Board creados en memoria.\n- Al final de cada prueba se limpia app.dependency_overrides para no afectar otras pruebas.",
        "detail": "backend.tests.boards.test_routes_boards",
        "documentation": {}
    },
    {
        "label": "test_login_exitoso",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_login_exitoso(page):\n    \"\"\"Verifica que un usuario con credenciales válidas pueda iniciar sesión.\n    Flujo de la prueba:\n    1. Navega a la página de login.\n    2. Rellena los campos de email y contraseña con credenciales válidas.\n    3. Envía el formulario de login.\n    4. Espera a que la aplicación redirija a la ruta de tableros (/boards).\n    Aserciones/condiciones:\n    - Se espera una redirección a una URL que contenga '/boards'.\n    - Hay una comprobación comentada que valida la presencia del texto \"Bienvenido\" en el contenido de la página;",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_login_fallido",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_login_fallido(page):\n    \"\"\"Verifica que el sistema muestra un mensaje de error cuando las credenciales son incorrectas.\n    Flujo de la prueba:\n    1. Navega a la página de login.\n    2. Rellena los campos de email y contraseña con credenciales incorrectas.\n    3. Envía el formulario de login.\n    4. Espera a que aparezca un selector con el mensaje de error esperado.\n    Aserciones/condiciones:\n    - Se espera que el selector de texto con el mensaje de error esté presente:\n    \"No se ha podido iniciar sesión (API no disponible o credenciales incorrectas)\".",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_dashboard_protegido",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_dashboard_protegido(page):\n    \"\"\"Verifica que la ruta /dashboard está protegida y redirige a /login si no hay token.\n    Flujo de la prueba:\n    1. Intenta navegar directamente a /dashboard sin establecer token en localStorage.\n    2. Espera la redirección a la página de login.\n    Aserciones/condiciones:\n    - La URL final contiene '/login', lo que indica que el acceso fue denegado y se pidió autenticación.\n    \"\"\"\n    page.goto(f\"{BASE_URL}/dashboard\")\n    page.wait_for_url(\"**/login\")",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_dashboard_con_token",
        "kind": 2,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "def test_dashboard_con_token(page):\n    \"\"\"Verifica que al establecer un token en localStorage se puede acceder a /dashboard.\n    Flujo de la prueba:\n    1. Navega a la página de login (para obtener el mismo origen y poder manipular localStorage).\n    2. Inserta un token simulado en window.localStorage.\n    3. Navega a /dashboard.\n    4. Espera la redirección/permiso de acceso a la ruta de dashboard.\n    Aserciones/condiciones:\n    - La URL final contiene '/dashboard', indicando acceso correcto con token presente.\n    - El token usado es un placeholder; si la aplicación valida el token en el backend, puede ser necesario mockear la respuesta de la API.",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "kind": 5,
        "importPath": "backend.tests.e2e.test_e2e",
        "description": "backend.tests.e2e.test_e2e",
        "peekOfCode": "BASE_URL = \"http://localhost:5173/\"\n\"\"\"\nPruebas E2E de autenticación y protección de rutas usando Playwright + pytest.\nEste módulo contiene pruebas que verifican:\n- Inicio de sesión exitoso y redirección al listado de tableros (/boards).\n- Manejo de inicio de sesión fallido con mensaje de error visible.\n- Protección de la ruta /dashboard para usuarios no autenticados.\n- Acceso a /dashboard cuando existe un token simulado en localStorage.\nNotas:\n- Estas pruebas asumen que la aplicación frontend está disponible en BASE_URL.",
        "detail": "backend.tests.e2e.test_e2e",
        "documentation": {}
    },
    {
        "label": "test_valores_por_defecto",
        "kind": 2,
        "importPath": "backend.tests.test_config",
        "description": "backend.tests.test_config",
        "peekOfCode": "def test_valores_por_defecto():\n    \"\"\"Comprueba los valores por defecto de la configuración.\n    Aserciones:\n    - DATABASE_URL tiene la ruta de prueba por defecto.\n    - SECRET_KEY, ALGORITHM y ACCESS_TOKEN_EXPIRE_MINUTES coinciden con los valores esperados.\n    \"\"\"\n    assert settings.DATABASE_URL == \"sqlite:///./test.db\"\n    assert settings.SECRET_KEY == \"your-secret-key-here\"\n    assert settings.ALGORITHM == \"HS256\"\n    assert settings.ACCESS_TOKEN_EXPIRE_MINUTES == 30",
        "detail": "backend.tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_carga_desde_env",
        "kind": 2,
        "importPath": "backend.tests.test_config",
        "description": "backend.tests.test_config",
        "peekOfCode": "def test_carga_desde_env(monkeypatch):\n    \"\"\"Verifica que Settings carga y parsea correctamente valores desde variables de entorno.\n    Flujo:\n    1. Establecer variables de entorno con monkeypatch.\n    2. Instanciar Settings y comprobar que los atributos reflejan las variables establecidas.\n    Aserciones:\n    - DATABASE_URL, SECRET_KEY y ALGORITHM coinciden con las variables de entorno.\n    - ACCESS_TOKEN_EXPIRE_MINUTES se convierte correctamente a entero (45).\n    \"\"\"\n    monkeypatch.setenv(\"DATABASE_URL\", \"sqlite:///./env_test.db\")",
        "detail": "backend.tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_database_url_definida",
        "kind": 2,
        "importPath": "backend.tests.test_database",
        "description": "backend.tests.test_database",
        "peekOfCode": "def test_database_url_definida():\n    \"\"\"Comprueba que la configuración expone DATABASE_URL y que tiene un esquema plausible.\n    Aserciones:\n    - DATABASE_URL no es None.\n    - El valor comienza con 'postgresql://' o 'sqlite://', esquemas esperados en la aplicación.\n    \"\"\"\n    assert DATABASE_URL is not None\n    assert DATABASE_URL.startswith(\"postgresql://\") or DATABASE_URL.startswith(\"sqlite://\")\n# ----------------------------\n# Test 2: Crear engine y session",
        "detail": "backend.tests.test_database",
        "documentation": {}
    },
    {
        "label": "test_engine_y_session_local",
        "kind": 2,
        "importPath": "backend.tests.test_database",
        "description": "backend.tests.test_database",
        "peekOfCode": "def test_engine_y_session_local():\n    \"\"\"Verifica que el engine y SessionLocal exportados por app.database son utilizables.\n    Flujo:\n    1. Comprueba que `engine` está definido.\n    2. Intenta crear una sesión usando SessionLocal y cerrar la sesión.\n    Aserciones:\n    - `engine` no es None.\n    - La sesión creada por SessionLocal se puede instanciar y cerrar sin errores.\n    \"\"\"\n    assert engine is not None",
        "detail": "backend.tests.test_database",
        "documentation": {}
    },
    {
        "label": "test_crear_tablas_temporales",
        "kind": 2,
        "importPath": "backend.tests.test_database",
        "description": "backend.tests.test_database",
        "peekOfCode": "def test_crear_tablas_temporales():\n    \"\"\"Crea un engine SQLite en memoria, genera las tablas definidas en Base y abre una sesión.\n    Flujo:\n    1. Crear un engine SQLite en memoria y un sessionmaker ligado a él.\n    2. Llamar a Base.metadata.create_all(bind=test_engine) para crear las tablas.\n    3. Abrir y cerrar una sesión para verificar que la configuración de metadatos y conexión funciona.\n    Aserciones:\n    - Se puede instanciar y cerrar una sesión sobre la base temporal sin errores.\n    \"\"\"\n    test_engine = create_engine(\"sqlite:///:memory:\", echo=False)",
        "detail": "backend.tests.test_database",
        "documentation": {}
    },
    {
        "label": "test_root_endpoint",
        "kind": 2,
        "importPath": "backend.tests.test_main",
        "description": "backend.tests.test_main",
        "peekOfCode": "def test_root_endpoint():\n    \"\"\"Comprueba que el endpoint raíz devuelve el estado esperado.\n    Flujo:\n    1. Realiza una petición GET a \"/\".\n    2. Verifica que el status code es 200.\n    3. Comprueba que el JSON devuelto coincide con {\"status\": \"NeoCare Backend Running\"}.\n    Aserciones:\n    - response.status_code == 200\n    - response.json() == {\"status\": \"NeoCare Backend Running\"}\n    \"\"\"",
        "detail": "backend.tests.test_main",
        "documentation": {}
    },
    {
        "label": "test_auth_router_included",
        "kind": 2,
        "importPath": "backend.tests.test_main",
        "description": "backend.tests.test_main",
        "peekOfCode": "def test_auth_router_included():\n    \"\"\"Verifica de forma indirecta que el router de autenticación está montado.\n    Flujo:\n    1. Realiza una petición GET a \"/auth\".\n    2. Como es probable que no exista un GET en la raíz del router auth, se acepta\n    que la respuesta sea 404 (no encontrado) o 405 (método no permitido).\n    Si el router no estuviera incluido, algunas configuraciones podrían también\n    devolver 404; por eso se comprueba que el código esté entre [404, 405].\n    Aserciones:\n    - response.status_code está en [404, 405]",
        "detail": "backend.tests.test_main",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "backend.tests.test_main",
        "description": "backend.tests.test_main",
        "peekOfCode": "client = TestClient(app)\n\"\"\"Pruebas básicas de los endpoints expuestos por la aplicación principal (app.main).\nEste módulo contiene tests ligeros que verifican:\n- El endpoint raíz (GET /) responde correctamente con el estado esperado.\n- Que el router de autenticación está registrado en la aplicación (comprobado mediante\nuna petición a la ruta base de auth que debería devolver 404 o 405 si no hay un GET definido).\nEstas pruebas usan TestClient de FastAPI para realizar peticiones HTTP en memoria.\n\"\"\"\n# ----------------------------\n# Test GET /",
        "detail": "backend.tests.test_main",
        "documentation": {}
    },
    {
        "label": "read_root",
        "kind": 2,
        "importPath": "backend.prueba",
        "description": "backend.prueba",
        "peekOfCode": "def read_root():\n    \"\"\"\nMódulo FastAPI de ejemplo simple.\nExpone dos endpoints:\n- \"/\"        : Mensaje de bienvenida y verificación de estado.\n- \"/items/{item_id}\" : Retorna información de un ítem usando parámetros de path y query.\n\"\"\"\n    return {\"message\": \"Hola Néstor, FastAPI ya está funcionando 🚀\"}\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str | None = None):",
        "detail": "backend.prueba",
        "documentation": {}
    },
    {
        "label": "read_item",
        "kind": 2,
        "importPath": "backend.prueba",
        "description": "backend.prueba",
        "peekOfCode": "def read_item(item_id: int, q: str | None = None):\n    \"\"\"\n    Obtiene la información de un ítem según su ID y parámetro opcional de búsqueda.\n    Args:\n        item_id (int): Identificador del ítem recibido desde la URL (path).\n        q (str, optional): Parámetro de consulta (query string) opcional.\n    Returns:\n        dict: Diccionario con el ID del ítem, query recibido y mensaje de prueba.\n    \"\"\"\n    return {",
        "detail": "backend.prueba",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend.prueba",
        "description": "backend.prueba",
        "peekOfCode": "app = FastAPI()\n@app.get(\"/\")\ndef read_root():\n    \"\"\"\nMódulo FastAPI de ejemplo simple.\nExpone dos endpoints:\n- \"/\"        : Mensaje de bienvenida y verificación de estado.\n- \"/items/{item_id}\" : Retorna información de un ítem usando parámetros de path y query.\n\"\"\"\n    return {\"message\": \"Hola Néstor, FastAPI ya está funcionando 🚀\"}",
        "detail": "backend.prueba",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "backend.test",
        "description": "backend.test",
        "peekOfCode": "def main():\n    r = requests.get(\"https://httpbin.org/get\")\n    print(r.status_code, r.headers.get(\"Content-Type\"))\nif __name__ == \"__main__\":\n    main()",
        "detail": "backend.test",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "frontend.node_modules.flatted.python.flatted",
        "description": "frontend.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "frontend.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "frontend_t.node_modules.flatted.python.flatted",
        "description": "frontend_t.node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "frontend_t.node_modules.flatted.python.flatted",
        "documentation": {}
    }
]